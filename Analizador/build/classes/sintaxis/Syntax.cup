package sintaxis;

import java_cup.runtime.*;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Collection;

// Aquí va la gramática BNF que hicimos solo que se pone con ::= en vez de la flecha 
// También se declaran los terminales y los no terminales por medio de los símbolos y las producciones

// CODIGO JAVA 

action code {:
    LexerCup lex;
    private Object symbolFactory;
    Symbol token;
    Boolean errores = false;
    HashMap<String, ArrayList<String>> listaTablaSimbolos = new HashMap<String, ArrayList<String>>();
    String currentHash;
    int currentTemp = 0;
    StringBuilder codIn3D = new StringBuilder();
    ArrayList<String> elementosArray = new ArrayList<>();
    ArrayList<String> elementosParametros = new ArrayList<>();
    int contador_for = 0;
    int contador_while = 0;
    int contador_if = 0;
    int contador_fin_if = 1;
    int contador_if_anidados = 0;
    int contador_else = 0;
    String fatherCurrentHash = null;
    LinkedList<String> hashTree = new LinkedList<>();
    int currentHashPos = 0;
    StringBuilder mipsData = new StringBuilder();
    StringBuilder mipsMain = new StringBuilder();
    String stringCreationMips = "";
    int mipsTemp = 0;

    public String existeFuncion(String idBuscado){
        Collection<ArrayList<String>> valores = listaTablaSimbolos.values();
        for (ArrayList<String> tablaSimbolos : valores){
            // Recorre los elementos del ArrayList
            for (String elemento : tablaSimbolos) {
                // Divide el elemento en ID y tipo
                String[] partes = elemento.split(":");
                if (partes[0].equals("tipo") && partes[2].equals(idBuscado)) { // Verifica si el ID coincide con el ID buscado
                    return partes[3].trim(); // Se encontró el ID de la función y se envía el tipo de la función
                }
            }
        }
        return null;   
    }

    /* Constructor del parser, recibe como parámetro el lexer que se va a utilizar 
        Entradas: Lexer lex
        Salidas: Ninguna
        Restricciones: Ninguna
    */

    @SuppressWarnings("deprecation")
    public void parser(LexerCup lex){
        this.lex = lex;
        this.symbolFactory = new DefaultSymbolFactory();
    }
    
    /* Método que se encarga de retornar el valor booleao de errores. Indicando si hubo errores o no
        Entradas: Ninguna
        Salidas: errores
        Restricciones: Ninguna
    */
    public boolean getErrores(){
        return errores;
    }

    /* Método que se encarga de retornar el string buffer del código intermedio 3 direcciones
        Entradas: Ninguna
        Salidas: codIn3D
        Restricciones: Ninguna
    */
    public StringBuilder getCodIn3D(){
        return codIn3D;
    }

    /*
        Método que se encarga de retornar el string buffer del código MIPS
        Entradas: Ninguna
        Salidas: mipsData
        Restricciones: Ninguna
    */
    public StringBuilder getMipsData(){
        return mipsData;
    }

    /*
        Método que se encarga de retornar el string buffer del código MIPS
        Entradas: Ninguna
        Salidas: mipsMain
        Restricciones: Ninguna
    */
    public StringBuilder getMipsMain(){
        return mipsMain;
    }
    /* Método que se encarga de imprimir la tabla de símbolos
        Entradas: Ninguna
        Salidas: Ninguna
        Restricciones: Ninguna
    */
    private void imprimirTablaSimbolos(){
        for(String key: listaTablaSimbolos.keySet()){
            System.out.println("-------------------------");
            System.out.println("Tabla de símbolos: "+key);
            System.out.println("Valores: ");
            for(String item: listaTablaSimbolos.get(key)){
                System.out.println(item);
            }
            System.out.println("");
        }
    }

     /* Método que se encarga de imprimir el string buffer del código intermedio 3 direcciones en la terminal.
        Entradas: Ninguna
        Salidas: Ninguna
        Restricciones: Ninguna
    */
    private void imprimirCodigo3D(){
        System.out.println("++++++++ CODIGO 3D +++++++++");
        System.out.println("");
        System.out.println(codIn3D.toString());
    }


    /* Método que se encarga de imprimir el string buffer del código MIPS en la terminal.
        Entradas: Ninguna
        Salidas: Ninguna
        Restricciones: Ninguna
    */
    private void imprimirCodigoMIPS(){
        System.out.println("++++++++ CODIGO MIPS +++++++++");
        System.out.println("");
        System.out.println(".data\n");
        System.out.println(mipsData.toString());
        System.out.println(".text\n");
        System.out.println(".globl main\n");
        System.out.println(mipsMain.toString());
        System.out.println("   li $v0, 10");
        System.out.println("   syscall");
    }

    /* Método que se encarga de imprimir el string buffer del código MIPS en un archivo .asm.
        Entradas: Ninguna
        Salidas: Ninguna
        Restricciones: Ninguna
    */
    private int addMipsTemp(){
        if (mipsTemp == 9){
            mipsTemp = 0;
        }else{
            mipsTemp++;
        }
        return mipsTemp;
    }

    /*
        Método que se encarga de retornar la tabla de símbolos
        Entradas: Ninguna
        Salidas: tabla de símbolos
        Restricciones: Ninguna
    */
    public HashMap<String, ArrayList<String>> getTablaSimbolos(){
        return listaTablaSimbolos;
    }

    /* Método que se encarga de imprimir en consola el error sintáctico
        Entradas: String error. Error que se va a imprimir
        Salidas: Ninguna. Imprime en consola el error
        Restricciones: Ninguna
    */
    private void manejoError(String error, String tipoError){
        errores = true;
        System.out.println("Error "+tipoError+": "+ error );
        System.out.println("Se continua con el análisis "+tipoError);
    } 

    /* Método que se encarga de buscar en la tabla de símbolos actual un ID y devolver su tipo.
        Entradas: lista: lista de elementos de la tabla de símbolos actual, idBuscado: ID que se requiere buscar y queBusca: si busca el ID de una variable o de una función. 
        Salidas: String o null
        Restricciones: Ninguna
    */
     private String buscarID_o_tipoID(ArrayList<String> tablaSimbolos, String idBuscado, String queBusca) {
        int treeSize = hashTree.indexOf(hashTree.get(currentHashPos));
        for (int i = treeSize; i >= 0; i--) {
            tablaSimbolos = listaTablaSimbolos.get(hashTree.get(i));
            if(queBusca.equals("id")){
                // Recorre los elementos del ArrayList
                for (String elemento : tablaSimbolos) {
                    // Divide el elemento en ID y tipo
                    String[] partes = elemento.split(": ");
                    if (partes[0].equals(idBuscado)) { // Verifica si el ID coincide con el ID buscado
                        return partes[1]; // Se encontró el ID y se envía el tipo del ID
                    }
                    if (partes[0].equals("Parámetro") && partes[1].equals(idBuscado)) { // Verifica si el ID coincide con el ID buscado
                        return partes[2].trim(); // Se encontró el ID y se envía el tipo del ID
                    }	
                }
            }
            else if(queBusca.equals("funcion")){
                // Recorre los elementos del ArrayList
                for (String elemento : tablaSimbolos) {
                    // Divide el elemento en ID y tipo
                    String[] partes = elemento.split(":");
                
                    if (partes[1].equals(idBuscado)) { // Verifica si el ID coincide con el ID buscado
                        return partes[2]; // Se encontró el ID de la función y se envía el tipo de la función
                    }
                }
            }
            else if(queBusca.equals("tamañoArray")){
                // Recorre los elementos del ArrayList
                for (String elemento : tablaSimbolos) {
                    // Divide el elemento en ID y tipo
                    String[] partes = elemento.split(": ");
                
                    if (partes[0].equals(idBuscado)) { // Verifica si el ID coincide con el ID buscado
                        return partes[2]; // Se encontró el ID de la función y se envía el tipo de la función
                    }
                }

            }
        }
        return null;       
    }

    private ArrayList<String> obtenerParametrosFuncion(String funcion){
        Collection<ArrayList<String>> valores = listaTablaSimbolos.values();
        ArrayList<String> parametros = new ArrayList<String>();
        for (ArrayList<String> tablaSimbolos : valores){
            // Recorre los elementos del ArrayList
            for (int i = 0; i < tablaSimbolos.size(); i++) {
                String elemento = tablaSimbolos.get(i);
                // Divide el elemento en ID y tipo
                String[] partes = elemento.split(":");
                if (partes[0].equals("tipo") && partes[2].equals(funcion)) { // Verifica si el ID coincide con el ID buscado
                    for (int j = i+1; j < tablaSimbolos.size(); j++){
                        String linea = tablaSimbolos.get(j); // Se encontró el ID de la función y se envía el tipo de la función
                        if(linea.contains("Parámetro")){
                            parametros.add(linea);
                        }
                    }
                    if (parametros.size() != 0){
                        return parametros;
                    }
                }
            }
        }
        return null;   
    }
    /*  Método que se encarga de verificar si todos los elementos de una lista tienen el mismo tipo de dato.
        Entradas: lista: lista de elementos en donde cada elemento contiene un string tipo: "elemento: tipo de dato". 
        Salidas: boolean, true o false.
        Restricciones: La lista NO puede estar vacía.
    */

    private String verificarTipo_elementosArray(ArrayList<String> lista, String tipoArray){

        for (int i = 0; i < lista.size(); i++) {
            String elemento = lista.get(i);
            String[] partesElemento = elemento.split(": ");
            String tipoDatoElemento = partesElemento[1].trim();

            if (!tipoDatoElemento.equals("error_semantico")){
                if (!tipoDatoElemento.equals(tipoArray)) {
                    return partesElemento[0]; // Los tipos de datos NO son iguales
                }
            }
            else{
                return "error_semantico";
            }  
        }
        return null; // Todos los elementos tienen el mismo tipo de dato
    }
    
:}

parser code {:
:}



//------------------------------------------------------------------------------------------------
terminal        ENDLINE,SEPARADOR,DOSPUNTOS,COMA,SIGNOIGUAL,SIGRESTA,SIGSUMA,SIGMULTI,SIGDIV,SIGMOD,SIGPOT,
                SIGCONJUNCION,SIGDISYUNCION,SIGNEGACION,SIGAUMEN,SIGDIMINU,SIGMENOR,SIGMENORIGUAL,SIGMAYOR,SIGMAYORIGUAL,IGUAL,SIGDIFERENTE,SIGABREPARENT,
                SIGCIERRAPARENT,SIGABRELLAVES,SIGCIERRALLAVES,LITTRUE,LITFALSE,TIPOINT,TIPOFLOAT,TIPOBOOL,TIPOCHAR,TIPOSTRING,RESERVLEER,
                RESERVESCRIBIR,RESERVIF,RESERVELSE,RESERVSWITCH,RESERVWHILE,RESERVFORRANGE,RESERVMAIN,RESERVBREAK,RESERVRETURN,
                RESERVCASE,RESERVDEFAULT,LITINT,LITFLOAT,LITCHAR,LITSTRING,IDENTIFICADOR,COMENTARIOSIMPLE,COMENTARIOMULTIPLE;

non terminal    LITBOOL,OPERADORESARITME,OPERADORESLOGICOS,OPERADORESUNARIOS,OPERADORESRELA,COMENTARIOS,DATOSRETORNO,                
                SENTRETURN,SENTBREAK,OPERAUNARIA,OPERACIONUNARIA,VALORESARIT,OPERACIONARIT,ASIGNVAR,CREAVARINT,CREAASIGVARINT,                
                VARIABLESINT,CREAVARFLOAT,CREAASIGVARFLOAT,VARIABLESFLOAT,VALORESBOOL,       PARAMETROFUNCION,      FINIF, INICIOIF,   
                CREAVARBOOL,CREAASIGVARBOOL,VARIABLESBOOL,VALORESCHAR,CREAVARCHAR,CREAASIGVARCHAR,VARIABLESCHAR,                
                VALORESSTRING,CREAVARSTRING,CREAASIGVARSTRING,VARIABLESSTRING,VARIABLES,FUNCLEER,FUNCESCRIBIRINT,                
                FUNCESCRIBIRFLOAT,FUNCESCRIBIRSTRING,FUNCESCRIBIRID,FUNCESCRIBIR,OPERADORESBOOL,OPERANDOBOOLEANO,OPERACIONBOOL,
                OPERACIONRELAARIT,OPERANDOSLOGICOS,OPERACIONLOGICAS,CONDICIONES,SENTENCIA,ESTRUCTCONTROL,VALORESBLOQUECODIGO,                
                BLOQUECODIGO,ESTRUCTELSE,ESTRUCTIF,PARAMFORRANGEUNO,PARAMFORRANGEDOS,PARAMFORRANGETRES,PARAMFORRANGE,ESTRUCTFORRANGE,                
                ESTRUCTWHILE,LITERAL,CASE,CASES,DEFAULT,ESTRUCTSWITCH,TIPOSPARAM,PARAMFUNCIONES,FUNCMAIN,CREAFUNC,CONDICIONALFOR,                
                PARMFUNC,PARAMLLAMARFUNC,PARAMLLAMAFUNC,LLAMARFUNC,SENTLLAMARFUNC,GLOBALVAR,VALORPROGRAMA,INIFUN,VALORESPROGRAMA,PROGRAMA,INICIO,VALORESCONDI,INIFUNMAIN,INICIOFOR,TIPORETORNO;

precedence left TIPOINT , TIPOFLOAT , TIPOBOOL , TIPOCHAR ;
precedence left SIGCONJUNCION, SIGDISYUNCION;

start with INICIO;

LITBOOL             ::= LITTRUE {: RESULT = "true"+": "+"bool"; :}
                        | LITFALSE {: RESULT = "false"+": "+"bool"; :};

OPERADORESARITME    ::= SIGRESTA {: RESULT = "-";:} 
                        | SIGSUMA {: RESULT = "+";:} 
                        | SIGMULTI {: RESULT = "*";:} 
                        | SIGDIV {: RESULT = "/";:} 
                        | SIGMOD {: RESULT = "%";:} 
                        | SIGPOT{: RESULT = "^";:};

OPERADORESLOGICOS   ::= SIGCONJUNCION {: RESULT = "&";:} 
                        | SIGDISYUNCION{: RESULT = "|";:};

OPERADORESUNARIOS   ::= SIGAUMEN {: RESULT = "++";:} 
                        | SIGDIMINU {: RESULT = "--";:};

COMENTARIOS         ::= COMENTARIOSIMPLE | COMENTARIOMULTIPLE;

DATOSRETORNO        ::= LITINT:litInt {: RESULT = litInt.toString()+": "+"int"; :}
                        | LITFLOAT:litfloat {: RESULT = litfloat.toString()+": "+"float"; :} 
                        | LITBOOL 
                        | IDENTIFICADOR 
                        | LLAMARFUNC ;
SENTRETURN          ::= RESERVRETURN SEPARADOR DATOSRETORNO ENDLINE;

OPERAUNARIA         ::= IDENTIFICADOR OPERADORESUNARIOS;
OPERAUNARIA         ::= OPERADORESUNARIOS IDENTIFICADOR ;
OPERACIONUNARIA     ::= OPERAUNARIA ENDLINE;

VALORESARIT         ::= LITINT:litInt {: RESULT = litInt.toString()+": "+"int"; :}
                        | LITFLOAT:litfloat {: RESULT = litfloat.toString()+": "+"float"; :}
                        | IDENTIFICADOR : id {: RESULT = id+": "+"var"; :} 
                        | LLAMARFUNC 
                        | OPERAUNARIA;                        
OPERACIONARIT       ::= VALORESARIT:valor {:RESULT = valor ;:}
                        | VALORESARIT:valor1 OPERADORESARITME:sig OPERACIONARIT:valor2 {: 
                            String[] partes_valor1 = valor1.toString().split(": ");
                            String[] partes_valor2 = valor2.toString().split(": ");
                            boolean errores = false;

                            if (!(partes_valor1[1].equals("float")) && (!partes_valor1[1].equals("int")) && (!partes_valor1[1].equals("var"))){
                                //Manejo error semántico
                                errores = true;
                                manejoError("'" + valor1 + " " + sig + " " + valor2 + "' El operador: "+ valor1 +" es de un tipo incorrecto para una operacion aritmetica, dentro de "+currentHash, "semántico");
                                RESULT = "error_semantico";
                            }
                            if (!(partes_valor2[1].equals("float")) && (!partes_valor2[1].equals("int")) && (!partes_valor2[1].equals("var"))){
                                //Manejo error semántico
                                errores = true;
                                manejoError("'" + valor1 + " " + sig + " " + valor2 + "' El operador: "+ valor2 +" es de un tipo incorrecto para una operacion aritmetica, dentro de "+currentHash, "semántico");
                                RESULT = "error_semantico";                               
                            }   
                            if (partes_valor1[1].equals(partes_valor2[1]) || partes_valor1[1].equals("var") || partes_valor2[1].equals("var")){
                                if (!errores){
                                    String tipo = "";
                                    if (partes_valor1[1].equals("var")&& (!partes_valor2[1].equals("var"))){
                                        tipo = partes_valor2[1];
                                    }else{
                                        if (partes_valor2[1].equals("var")&& (!partes_valor1[1].equals("var"))){
                                            tipo = partes_valor1[1];
                                        }else{
                                            if ((!partes_valor2[1].equals("var")) && (!partes_valor1[1].equals("var"))){
                                                tipo = partes_valor1[1];
                                            }else{
                                                tipo = buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), partes_valor1[0], "id");
                                            }
                                        }
                                        
                                    }
                                    String temp = "(" + partes_valor1[0] + sig + partes_valor2[0] +")";
                                    RESULT = temp + ": " + tipo; 
                                }
                            }else{
                                //Manejo error semántico
                                manejoError("'" + valor1 + " " + sig + " " + valor2 + "' Los operadores no son del mismo tipo, dentro de "+currentHash, "semántico");
                                RESULT = "error_semantico";                                 
                            }
                        :} 
                        | SIGABREPARENT OPERACIONARIT:valor1 SIGCIERRAPARENT {:RESULT = valor1 ;:};

ASIGNVAR            ::= IDENTIFICADOR SIGNOIGUAL OPERACIONARIT ENDLINE;
                    

CREAVARINT          ::= TIPOINT:tip SEPARADOR IDENTIFICADOR:id ENDLINE
                {:   // ++++ Análisis semántico ++++
                    if(fatherCurrentHash != null && buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), id.toString(), "id") == null){
                        if(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null ) {
                            // ++++ Código 3D ++++
                            codIn3D.append("\ndataInt"+" "+id.toString());
                            mipsData.append("   " + id.toString()+": ."+"word 0"+"\n");

                            // +++ Tabla de símbolos ++++ 
                            listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                            RESULT = id.toString()+": "+tip.toString();
                        }
                        else{
                            //Manejo error semántico
                            manejoError("'" + tip +" # "+ id + ";' " + "El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+currentHash, "semántico");
                            RESULT = "error_semantico";
                        }
                    }
                    else if(fatherCurrentHash == null && buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null){
                            // ++++ Código 3D ++++
                            codIn3D.append("\ndataInt"+" "+id.toString());
                            mipsData.append("   " + id.toString()+": ."+"word 0"+"\n");

                            // +++ Tabla de símbolos ++++ 
                            listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                            RESULT = id.toString()+": "+tip.toString();
                    }
                    else{
                        //Manejo error semántico
                        manejoError("El ID: '"+id+"' ya ha sido utilizado en otra creación de variable dentro de "+fatherCurrentHash, "semántico");
                        RESULT = "error_semantico";
                    }
                :}; 

CREAASIGVARINT      ::= TIPOINT:tip SEPARADOR IDENTIFICADOR:id SIGNOIGUAL OPERACIONARIT:op ENDLINE
                 {:   // ++++ Análisis semántico ++++
                    String ladoIzqTipo = tip.toString();
                    String ladoIzqId = id.toString(); 
                    String[] partes_op = op.toString().split(": ");

                    if((ladoIzqTipo.equals(partes_op[1].toString())) || (partes_op[1].toString().equals("var"))){
                        if(!(ladoIzqTipo.equals(partes_op[1].toString())) && buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), partes_op[0].toString(), "id") == null){
                            //Manejo error semántico
                            manejoError("'" + tip +" # "+ id + " = " + partes_op[0] + ";' " + "El ID: '"+ partes_op[0] +"' no ha sido creado anteriormente", "semántico");
                            RESULT = "error_semantico";
                        }else{
                            if (!(ladoIzqTipo.equals(partes_op[1])) && !(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), partes_op[0], "id").equals("int"))){
                                //Manejo error semántico
                                manejoError("'" + tip +" # "+ id + " = " + partes_op[0] + ";' " + "La variable: '"+ partes_op[0] +"' no es de tipo int", "semántico");
                                RESULT = "error_semantico";
                            }else{
                                if(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null ) {
                                    // ++++ Código 3D ++++
                                    String temp = "t"+(currentTemp++); 
                                    if (currentTemp == 10){
                                        currentTemp = 0;
                                    }
                                    codIn3D.append("\ndataInt "+ladoIzqId+" = "+partes_op[0].toString());
                                    mipsData.append("   " + ladoIzqId+": ."+"word 0"+"\n");

                                    String mipsAsignation = "li $"+temp+", "+ partes_op[0];
                                    mipsMain.append("\n   "+mipsAsignation);

                                    mipsAsignation = "sw "+temp+", "+ladoIzqId.toString();                            
                                    mipsMain.append("\n   "+mipsAsignation);
                                    RESULT = "int ::"+temp; 

                                    // +++ Tabla de símbolos ++++ 
                                    listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                                    RESULT = id.toString()+": "+tip.toString();
                                }else{
                                    //Manejo error semántico
                                    manejoError("'" + tip +" # "+ id + ";' " + "El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+currentHash, "semántico");
                                    RESULT = "error_semantico";
                                }
                            }
                        }
                    }
                    else{
                        //Manejo error semántico
                        manejoError("'" + tip +" # "+ id + " = " + partes_op[0] + ";' " + "El tipo de dato de '"+partes_op[0]+"' es incompatible", "semántico");
                        RESULT = "error_semantico";
                    }
                :} ;

VARIABLESINT        ::= ASIGNVAR 
                        | CREAVARINT 
                        | CREAASIGVARINT;

CREAVARFLOAT        ::= TIPOFLOAT:tip SEPARADOR IDENTIFICADOR:id ENDLINE
                {:   // ++++ Análisis semántico ++++
                    if(fatherCurrentHash != null && buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), id.toString(), "id") == null){
                        if(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null ) {
                            // ++++ Código 3D ++++
                            codIn3D.append("\ndataFloat"+" "+id.toString());
                            mipsData.append("   " + id.toString()+": ."+"float 0.0"+"\n");

                            // +++ Tabla de símbolos ++++ 
                            listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                            RESULT = id.toString()+": "+tip.toString();
                        }
                        else{
                            //Manejo error semántico
                            manejoError("El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+currentHash, "semántico");
                            RESULT = "error_semantico";
                        }
                    }
                    else if(fatherCurrentHash == null && buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null){
                            // ++++ Código 3D ++++
                            codIn3D.append("\ndataFloat"+" "+id.toString());
                            mipsData.append("   " + id.toString()+": ."+"float 0.0"+"\n");

                            // +++ Tabla de símbolos ++++ 
                            listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                            RESULT = id.toString()+": "+tip.toString();
                    }
                    else{
                        //Manejo error semántico
                        manejoError("El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+fatherCurrentHash, "semántico");
                        RESULT = "error_semantico";
                    }
                :}; 

CREAASIGVARFLOAT    ::= TIPOFLOAT:tip SEPARADOR IDENTIFICADOR:id SIGNOIGUAL OPERACIONARIT:op ENDLINE
                   {:   // ++++ Análisis semántico ++++
                    String ladoIzqTipo = tip.toString();
                    String ladoIzqId = id.toString(); 
                    String[] partes_op = op.toString().split(": ");
                    if((ladoIzqTipo.equals(partes_op[1].toString())) || (partes_op[1].toString().equals("var"))){
                        if(!(ladoIzqTipo.equals(partes_op[1].toString())) && buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), partes_op[0].toString(), "id") == null){
                            //Manejo error semántico
                            manejoError("'" + tip +" # "+ id + " = " + partes_op[0] + ";' " + "El ID: '"+ partes_op[0] +"' no ha sido creado anteriormente", "semántico");
                            RESULT = "error_semantico";
                        }else{
                            if (!(ladoIzqTipo.equals(partes_op[1])) && !(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), partes_op[0], "id").equals("float"))){
                                //Manejo error semántico
                                manejoError("'" + tip +" # "+ id + " = " + partes_op[0] + ";' " + "La variable: '"+ partes_op[0] +"' no es de tipo float", "semántico");
                                RESULT = "error_semantico";
                            }else{
                                if(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null ) {
                                    // ++++ Código 3D ++++
                                    String temp = "t"+(currentTemp++); 
                                    if (currentTemp == 10){
                                        currentTemp = 0;
                                    }
                                    codIn3D.append("\ndataFloat "+ladoIzqId+" = "+partes_op[0].toString());
                                    mipsData.append("   " + ladoIzqId+": ."+"float 0.0"+"\n");

                                    String mipsAsignation = "li $"+temp+", "+ partes_op[0];
                                    mipsMain.append("\n   "+mipsAsignation);

                                    mipsAsignation = "sw "+temp+", "+ladoIzqId.toString();                            
                                    mipsMain.append("\n   "+mipsAsignation);
                                    RESULT = "float ::"+temp; 

                                    // +++ Tabla de símbolos ++++ 
                                    listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                                    RESULT = id.toString()+": "+tip.toString();
                                }else{
                                    //Manejo error semántico
                                    manejoError("'" + tip +" # "+ id + ";' " + "El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+currentHash, "semántico");
                                    RESULT = "error_semantico";
                                }
                            }
                        }
                    }
                    else{
                        //Manejo error semántico
                        manejoError("'" + tip +" # "+ id + " = " + partes_op[0] + ";' " + "El tipo de dato de '"+partes_op[0]+"' es incompatible", "semántico");
                        RESULT = "error_semantico";
                    }
                :} ;



VARIABLESFLOAT      ::= CREAVARFLOAT 
                        | CREAASIGVARFLOAT;

VALORESBOOL         ::= LITBOOL:litBool {: RESULT = litBool.toString()+": "+"bool"; :}  
                        | IDENTIFICADOR: id {: RESULT = id+": "+"var"; :}   
                        | SIGABREPARENT OPERACIONRELAARIT:valor SIGCIERRAPARENT{:RESULT = valor ;:}  
                        | OPERACIONBOOL{: System.out.println("Que paso?"); :};

CREAVARBOOL         ::= TIPOBOOL:tip SEPARADOR IDENTIFICADOR:id ENDLINE
                {:   // ++++ Análisis semántico ++++
                    if(fatherCurrentHash != null && buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), id.toString(), "id") == null){
                        if(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null ) {
                            // ++++ Código 3D ++++
                            codIn3D.append("\ndataBool"+" "+id.toString());
                            mipsData.append("   " + id.toString()+": ."+"word 0"+"\n");

                            // +++ Tabla de símbolos ++++ 
                            listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                            RESULT = id.toString()+": "+tip.toString();
                        }
                        else{
                            //Manejo error semántico
                            manejoError("El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+currentHash, "semántico");
                            RESULT = "error_semantico";
                        }
                    }
                    else if(fatherCurrentHash == null && buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null){
                            // ++++ Código 3D ++++
                            codIn3D.append("\ndataBool"+" "+id.toString());
                            mipsData.append("   " + id.toString()+": ."+"word 0"+"\n");

                            // +++ Tabla de símbolos ++++ 
                            listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                            RESULT = id.toString()+": "+tip.toString();
                    }
                    else{
                        //Manejo error semántico
                        manejoError("El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+fatherCurrentHash, "semántico");
                        RESULT = "error_semantico";
                    }
                :};  

CREAASIGVARBOOL     ::= TIPOBOOL:tip SEPARADOR IDENTIFICADOR:id SIGNOIGUAL VALORESBOOL:dato ENDLINE 
                {: // ++++ Análisis semántico ++++
                    String ladoIzqTipo = tip.toString();
                    String ladoIzqId = id.toString();
                    String[] partes_dato = dato.toString().split(": ");
                    
                    if ((ladoIzqTipo.equals(partes_dato[1])) || (partes_dato[1].equals("var"))){
                         if(!(ladoIzqTipo.equals(partes_dato[1])) && buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), partes_dato[0].toString(), "id") == null){
                            //Manejo error semántico
                            manejoError("'" + tip +" # "+ id + " = " + partes_dato[0] + ";' " + "El ID: '"+ partes_dato[0] +"' no ha sido creado anteriormente", "semántico");
                            RESULT = "error_semantico";
                        }else{
                            if (!(ladoIzqTipo.equals(partes_dato[1])) && !(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), partes_dato[0], "id").equals("bool"))){
                                //Manejo error semántico
                                manejoError("'" + tip +" # "+ id + " = " + partes_dato[0] + ";' " + "La variable: '"+ partes_dato[0] +"' no es de tipo bool", "semántico");
                                RESULT = "error_semantico";
                            }else{
                                if(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null ) {
                                    // ++++ Código 3D ++++
                                    String temp = "t"+(currentTemp++); 
                                    if (currentTemp == 10){
                                        currentTemp = 0;
                                    }
                                    codIn3D.append("\ndataBool "+ladoIzqId+" = "+partes_dato[0].toString());
                                    mipsData.append("   " + ladoIzqId+": ."+"word 0"+"\n");

                                    String mipsAsignation = "li $"+temp+", "+ partes_dato[0];
                                    mipsMain.append("\n   "+mipsAsignation);

                                    mipsAsignation = "sw "+temp+", "+ladoIzqId.toString();                            
                                    mipsMain.append("\n   "+mipsAsignation);
                                    RESULT = "bool ::"+temp; 

                                    // +++ Tabla de símbolos ++++ 
                                    listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                                    RESULT = id.toString()+": "+tip.toString();
                                }else{
                                    //Manejo error semántico
                                    manejoError("'" + tip +" # "+ id + " = " + partes_dato[0] + ";' " + "El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+currentHash, "semántico");
                                    RESULT = "error_semantico";
                                }
                            }
                        }
                    }else{
                        //Manejo error semántico
                        manejoError("El ID: "+ ladoIzqId.toString() +" no ha sido creado dentro de la función", "semántico");
                        RESULT = "error_semantico";
                    }
                :}
                        | TIPOBOOL:tip SEPARADOR IDENTIFICADOR:id SIGNOIGUAL SIGNEGACION VALORESBOOL:dato ENDLINE
                            {:// ++++ Análisis semántico ++++
                                String ladoIzqTipo = tip.toString();
                                String ladoIzqId = id.toString();
                                String[] partes_dato = dato.toString().split(": ");

                                if ((ladoIzqTipo.equals(partes_dato[1])) || (partes_dato[1].equals("var"))){
                                     if(!(ladoIzqTipo.equals(partes_dato[1])) && buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), partes_dato[0].toString(), "id") == null){
                                        //Manejo error semántico
                                        manejoError("'" + tip +" # "+ id + " = " + partes_dato[0] + ";' " + "El ID: '"+ partes_dato[0] +"' no ha sido creado anteriormente", "semántico");
                                        RESULT = "error_semantico";
                                    }else{
                                        if (!(ladoIzqTipo.equals(partes_dato[1])) && !(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), partes_dato[0], "id").equals("bool"))){
                                            //Manejo error semántico
                                            manejoError("'" + tip +" # "+ id + " = " + partes_dato[0] + ";' " + "La variable: '"+ partes_dato[0] +"' no es de tipo bool", "semántico");
                                            RESULT = "error_semantico";
                                        }else{
                                            if(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null ) {
                                                // ++++ Código 3D ++++
                                                if (currentTemp == 10){
                                                    currentTemp = 0;
                                                }
                                                Boolean datoFinal = false;
                                                if (partes_dato[0].equals(false)){
                                                    datoFinal=true;
                                                }
                                                codIn3D.append("\ndataBool "+ladoIzqId+" = "+datoFinal.toString());
                                                mipsData.append("   " + ladoIzqId+": ."+"word 0"+"\n");

                                                String temp = "t"+(currentTemp++); 
                                                String mipsAsignation = "li $"+temp+", "+ datoFinal.toString();
                                                mipsMain.append("\n   "+mipsAsignation);

                                                mipsAsignation = "sw "+temp+", "+ladoIzqId.toString();                            
                                                mipsMain.append("\n   "+mipsAsignation);
                                                RESULT = "bool ::"+temp; 

                                                // +++ Tabla de símbolos ++++ 
                                                listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                                                RESULT = id.toString()+": "+tip.toString();
                                            }else{
                                                //Manejo error semántico
                                                manejoError("'" + tip +" # "+ id + " = " + partes_dato[0] + ";' " + "El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+currentHash, "semántico");
                                                RESULT = "error_semantico";
                                            }
                                        }
                                    }
                                }else{
                                    //Manejo error semántico
                                    manejoError("El ID: "+ ladoIzqId.toString() +" no ha sido creado dentro de la función", "semántico");
                                    RESULT = "error_semantico";
                                } 
                            :};

VARIABLESBOOL       ::= CREAVARBOOL 
                        | CREAASIGVARBOOL;

VALORESCHAR         ::= LITCHAR:litChar {: RESULT = litChar.toString()+": "+"char"; :} 
                        | IDENTIFICADOR:id {: RESULT = id+": "+"var"; :};

CREAVARCHAR         ::= TIPOCHAR:tip SEPARADOR IDENTIFICADOR:id ENDLINE
                {:   // ++++ Análisis semántico ++++
                    if(fatherCurrentHash != null && buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), id.toString(), "id") == null){
                        if(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null ) {
                            // ++++ Código 3D ++++
                            codIn3D.append("\ndataChar"+" "+id.toString());
                            mipsData.append("   " + id.toString()+": ."+"byte 0"+"\n");

                            // +++ Tabla de símbolos ++++ 
                            listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                            RESULT = id.toString()+": "+tip.toString();
                        }
                        else{
                            //Manejo error semántico
                            manejoError("El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+currentHash, "semántico");
                            RESULT = "error_semantico";
                        }
                    }
                    else if(fatherCurrentHash == null && buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null){
                            // ++++ Código 3D ++++
                            codIn3D.append("\ndataChar"+" "+id.toString());
                            mipsData.append("   " + id.toString()+": ."+"byte 0"+"\n");

                            // +++ Tabla de símbolos ++++ 
                            listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                            RESULT = id.toString()+": "+tip.toString();
                    }
                    else{
                        //Manejo error semántico
                        manejoError("El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+fatherCurrentHash, "semántico");
                        RESULT = "error_semantico";
                    }
                :};   

CREAASIGVARCHAR     ::= TIPOCHAR:tip SEPARADOR IDENTIFICADOR:id SIGNOIGUAL VALORESCHAR:dato ENDLINE
                  {: // ++++ Análisis semántico ++++
                    String ladoIzqTipo = tip.toString();
                    String ladoIzqId = id.toString();
                    String[] partes_dato = dato.toString().split(": ");
                    
                    if ((ladoIzqTipo.equals(partes_dato[1])) || (partes_dato[1].equals("var"))){
                         if(!(ladoIzqTipo.equals(partes_dato[1])) && buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), partes_dato[0].toString(), "id") == null){
                            //Manejo error semántico
                            manejoError("'" + tip +" # "+ id + " = " + partes_dato[0] + ";' " + "El ID: '"+ partes_dato[0] +"' no ha sido creado anteriormente", "semántico");
                            RESULT = "error_semantico";
                        }else{
                            if (!(ladoIzqTipo.equals(partes_dato[1])) && !(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), partes_dato[0], "id").equals("char"))){
                                //Manejo error semántico
                                manejoError("'" + tip +" # "+ id + " = " + partes_dato[0] + ";' " + "La variable: '"+ partes_dato[0] +"' no es de tipo char", "semántico");
                                RESULT = "error_semantico";
                            }else{
                                if(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null ) {
                                    // ++++ Código 3D ++++
                                    String temp = "t"+(currentTemp++); 
                                    if (currentTemp == 10){
                                        currentTemp = 0;
                                    }
                                    codIn3D.append("\ndataChar "+ladoIzqId+" = "+partes_dato[0].toString());
                                    mipsData.append("   " + ladoIzqId+": ."+"byte 0"+"\n");

                                    String mipsAsignation = "li $"+temp+", "+ partes_dato[0];
                                    mipsMain.append("\n   "+mipsAsignation);

                                    mipsAsignation = "sw "+temp+", "+ladoIzqId.toString();                            
                                    mipsMain.append("\n   "+mipsAsignation);
                                    RESULT = "char ::"+temp; 

                                    // +++ Tabla de símbolos ++++ 
                                    listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                                    RESULT = id.toString()+": "+tip.toString();
                                }else{
                                    //Manejo error semántico
                                    manejoError("'" + tip +" # "+ id + " = " + partes_dato[0] + ";' " + "El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+currentHash, "semántico");
                                    RESULT = "error_semantico";
                                }
                            }
                        }
                    }else{
                        //Manejo error semántico
                        manejoError("El ID: "+ ladoIzqId.toString() +" no ha sido creado dentro de la función", "semántico");
                        RESULT = "error_semantico";
                    }
                :};

VARIABLESCHAR       ::= CREAVARCHAR 
                        | CREAASIGVARCHAR;

VALORESSTRING       ::= LITSTRING:litString {: RESULT = litString.toString()+": "+"string"; :}  
                        | IDENTIFICADOR:id {: RESULT = id+": "+"var"; :};

CREAVARSTRING       ::= TIPOSTRING:tip SEPARADOR IDENTIFICADOR:id ENDLINE
                {:   
                    // ++++ Análisis semántico ++++
                    if(fatherCurrentHash != null && buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), id.toString(), "id") == null){
                        if(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null ) {
                            // ++++ Código 3D ++++
                            codIn3D.append("\ndataString"+" "+id.toString());
                            mipsData.append("   " + id.toString()+": ."+"asciiz \"\""+"\n");

                            // +++ Tabla de símbolos ++++ 
                            listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                            RESULT = id.toString()+": "+tip.toString();
                        }
                        else{
                            //Manejo error semántico
                            manejoError("El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+currentHash, "semántico");
                            RESULT = "error_semantico";
                        }
                    }
                    else if(fatherCurrentHash == null && buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null){
                            // ++++ Código 3D ++++
                            codIn3D.append("\ndataString"+" "+id.toString());
                            mipsData.append("   " + id.toString()+": ."+"asciiz \"\""+"\n");

                            // +++ Tabla de símbolos ++++ 
                            listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                            RESULT = id.toString()+": "+tip.toString();
                    }
                    else{
                        //Manejo error semántico
                        manejoError("El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+fatherCurrentHash, "semántico");
                        RESULT = "error_semantico";
                    }
                :}; 

CREAASIGVARSTRING   ::= TIPOSTRING:tip SEPARADOR IDENTIFICADOR:id SIGNOIGUAL VALORESSTRING:dato ENDLINE
                   {: // ++++ Análisis semántico ++++
                    String ladoIzqTipo = tip.toString();
                    String ladoIzqId = id.toString();
                    String[] partes_dato = dato.toString().split(": ");

                    if ((ladoIzqTipo.equals(partes_dato[1])) || (partes_dato[1].equals("var"))){
                         if(!(ladoIzqTipo.equals(partes_dato[1])) && buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), partes_dato[0].toString(), "id") == null){
                            //Manejo error semántico
                            manejoError("'" + tip +" # "+ id + " = " + partes_dato[0] + ";' " + "El ID: '"+ partes_dato[0] +"' no ha sido creado anteriormente", "semántico");
                            RESULT = "error_semantico";
                        }else{
                            if (!(ladoIzqTipo.equals(partes_dato[1])) && !(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), partes_dato[0], "id").equals("string"))){
                                //Manejo error semántico
                                manejoError("'" + tip +" # "+ id + " = " + partes_dato[0] + ";' " + "La variable: '"+ partes_dato[0] +"' no es de tipo String", "semántico");
                                RESULT = "error_semantico";
                            }else{
                                if(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null ) {
                                    // ++++ Código 3D ++++
                                    String temp = "t"+(currentTemp++); 
                                    if (currentTemp == 10){
                                        currentTemp = 0;
                                    }
                                    codIn3D.append("\ndataString "+ladoIzqId+" = "+partes_dato[0].toString());
                                    mipsData.append("   " + ladoIzqId+": ."+"asciiz \"\""+"\n");

                                    String mipsAsignation = "li $"+temp+", "+ partes_dato[0];
                                    mipsMain.append("\n   "+mipsAsignation);

                                    mipsAsignation = "sw "+temp+", "+ladoIzqId.toString();                            
                                    mipsMain.append("\n   "+mipsAsignation);
                                    RESULT = "string ::"+temp; 

                                    // +++ Tabla de símbolos ++++ 
                                    listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                                    RESULT = id.toString()+": "+tip.toString();
                                }else{
                                    //Manejo error semántico
                                    manejoError("'" + tip +" # "+ id + " = " + partes_dato[0] + ";' " + "El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+currentHash, "semántico");
                                    RESULT = "error_semantico";
                                }
                            }
                        }
                    }else{
                        //Manejo error semántico
                        manejoError("El ID: "+ ladoIzqId.toString() +" no ha sido creado dentro de la función", "semántico");
                        RESULT = "error_semantico";
                    }
                :};

VARIABLESSTRING     ::= CREAVARSTRING 
                        | CREAASIGVARSTRING;

VARIABLES           ::= VARIABLESINT 
                        | VARIABLESFLOAT 
                        | VARIABLESBOOL 
                        | VARIABLESCHAR 
                        | VARIABLESSTRING 
                        | OPERACIONUNARIA;

FUNCLEER            ::= RESERVLEER SIGABREPARENT IDENTIFICADOR SIGCIERRAPARENT ENDLINE;

FUNCESCRIBIRINT     ::= RESERVESCRIBIR SIGABREPARENT LITINT SIGCIERRAPARENT ENDLINE;
FUNCESCRIBIRFLOAT   ::= RESERVESCRIBIR SIGABREPARENT LITFLOAT SIGCIERRAPARENT ENDLINE;
FUNCESCRIBIRSTRING  ::= RESERVESCRIBIR SIGABREPARENT LITSTRING SIGCIERRAPARENT ENDLINE;
FUNCESCRIBIRID      ::= RESERVESCRIBIR SIGABREPARENT IDENTIFICADOR SIGCIERRAPARENT ENDLINE;
FUNCESCRIBIR        ::= FUNCESCRIBIRINT 
                        | FUNCESCRIBIRFLOAT 
                        | FUNCESCRIBIRSTRING 
                        | FUNCESCRIBIRID;

OPERADORESBOOL      ::= IGUAL 
                        | SIGDIFERENTE;
OPERANDOBOOLEANO    ::= LITBOOL 
                        | IDENTIFICADOR;
OPERACIONBOOL       ::= OPERANDOBOOLEANO OPERADORESBOOL OPERANDOBOOLEANO;


OPERADORESRELA      ::= SIGMENOR 
                        | SIGMENORIGUAL 
                        | SIGMAYOR 
                        | SIGMAYORIGUAL 
                        | OPERADORESBOOL ;


OPERACIONRELAARIT    ::= VALORESARIT;
OPERACIONRELAARIT    ::= VALORESARIT OPERADORESRELA VALORESARIT;

OPERANDOSLOGICOS    ::=  LITBOOL:lit | SEPARADOR IDENTIFICADOR
                        | SIGABREPARENT OPERACIONRELAARIT SIGCIERRAPARENT;
OPERACIONLOGICAS    ::= OPERANDOSLOGICOS;
OPERACIONLOGICAS    ::= SIGNEGACION OPERANDOSLOGICOS;
OPERACIONLOGICAS    ::= OPERACIONLOGICAS OPERADORESLOGICOS OPERANDOSLOGICOS;
OPERACIONLOGICAS    ::= SIGABREPARENT OPERACIONLOGICAS SIGCIERRAPARENT;


VALORESCONDI        ::= OPERACIONLOGICAS | IDENTIFICADOR;
CONDICIONES         ::=  SIGABREPARENT VALORESCONDI SIGCIERRAPARENT;

BLOQUECODIGO        ::= VALORESBLOQUECODIGO BLOQUECODIGO
                        | VALORESBLOQUECODIGO 
                        | COMENTARIOS;

ESTRUCTELSE         ::= RESERVELSE SIGABRELLAVES BLOQUECODIGO SIGCIERRALLAVES;
ESTRUCTIF           ::= INICIOIF CONDICIONES SIGABRELLAVES BLOQUECODIGO SIGCIERRALLAVES ESTRUCTELSE FINIF
                        | INICIOIF CONDICIONES SIGABRELLAVES BLOQUECODIGO SIGCIERRALLAVES FINIF;
INICIOIF            ::= RESERVIF:reserv SEPARADOR {: 
                            String tipoTabla = "tipo:condicional:if";
                            ArrayList<String> listaSimbolos = new ArrayList<String>();
                            fatherCurrentHash = currentHash;
                            currentHash = "if_"+(++contador_if)+"_"+ hashTree.get(currentHashPos);
                            listaSimbolos.add(tipoTabla);
                            hashTree.addLast(currentHash);
                            currentHashPos++;
                            listaTablaSimbolos.put(currentHash, listaSimbolos);
                            codIn3D.append("\n_if_" + contador_if + ":");
                            mipsMain.append("\n_if_" + contador_if + ":");
                        :} ;

FINIF               ::= {:    
                            int diferencia = contador_if - contador_fin_if;                            
                            if (diferencia != 0 ){
                                if(contador_if_anidados == 0){contador_if_anidados = diferencia+1;}
                                codIn3D.append("\n_end_if_"+(contador_fin_if + contador_if_anidados-1)+":");
                                mipsMain.append("\n_end_if_"+(contador_fin_if + contador_if_anidados-1)+":");
                                contador_if_anidados -= 1;
                                if(contador_if_anidados == 0){                            
                                    contador_fin_if = contador_if+1;
                                    contador_if_anidados = 0;
                                }
                            }else{
                                codIn3D.append("\n_end_if_"+(contador_if)+":");
                                mipsMain.append("\n_end_if_"+(contador_if)+":");
                                contador_fin_if += 1;  
                            }      
                            //contador_fin_if += 1;  
                        :} ;

PARAMFORRANGEUNO    ::= VALORESARIT:param1
                        {:  
                            String[] partes_valor = param1.toString().split(": ");
                            boolean errores = false;
                            if ((!partes_valor[1].equals("int")) && (!partes_valor[1].equals("var"))){
                                //Manejo error semántico
                                errores = true;
                                manejoError(" El parametro: '"+ partes_valor[0] +"' es de un tipo incorrecto para un parametro del 'forRange', dentro de "+currentHash, "semántico");
                                RESULT = "error_semantico";
                            }else{
                                if (partes_valor[1].equals("var")){
                                    String tipo = buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), partes_valor[0], "id");
                                    if(tipo == null){
                                        //Manejo error semántico
                                        errores = true;
                                        manejoError(" El parametro: '"+ partes_valor[0] +"' es de un variable la cual no ha sido definida previamente, dentro de "+currentHash, "semántico");
                                        RESULT = "error_semantico";
                                    }else {
                                        if(tipo.equals("int")){
                                            RESULT = "1".toString()+": " + "1".toString()+": " + partes_valor[0];
                                        }else{
                                            //Manejo error semántico
                                            errores = true;
                                            manejoError(" El parametro: '"+ partes_valor[0] +"' el tipo de dato de la variable no es correcto, dentro de "+currentHash, "semántico");
                                            RESULT = "error_semantico";
                                        }
                                    }
                                }else{
                                    RESULT = "1".toString()+": " + "1".toString()+": " + partes_valor[0];
                                }
                            }
                        :};
PARAMFORRANGEDOS    ::= VALORESARIT:param1 ENDLINE VALORESARIT:param2
                        {:  
                            String[] partes_valor = param1.toString().split(": ");
                            String[] partes_valor2 = param2.toString().split(": ");
                            boolean errores = false;
                            if ((!partes_valor[1].equals("int")) && (!partes_valor[1].equals("var"))){
                                //Manejo error semántico
                                errores = true;
                                manejoError(" El parametro: '"+ partes_valor[0] +"' es de un tipo incorrecto para un parametro del 'forRange', dentro de "+currentHash, "semántico");
                                RESULT = "error_semantico";
                            }else{
                                if (partes_valor[1].equals("var")){
                                    String tipo = buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), partes_valor[0], "id");
                                    if(tipo == null){
                                        //Manejo error semántico
                                        errores = true;
                                        manejoError(" El parametro: '"+ partes_valor[0] +"' es de un variable la cual no ha sido definida previamente, dentro de "+currentHash, "semántico");
                                        RESULT = "error_semantico";
                                    }else {
                                        if(!tipo.equals("int")){
                                            //Manejo error semántico
                                            errores = true;
                                            manejoError(" El parametro: '"+ partes_valor[0] +"' el tipo de dato de la variable no es correcto, dentro de "+currentHash, "semántico");
                                            RESULT = "error_semantico";
                                        }
                                    }
                                }
                            }
                            //validaciones param2
                            if ((!partes_valor2[1].equals("int")) && (!partes_valor2[1].equals("var"))){
                                //Manejo error semántico
                                errores = true;
                                manejoError(" El parametro: '"+ partes_valor2[0] +"' es de un tipo incorrecto para un parametro del 'forRange', dentro de "+currentHash, "semántico");
                                RESULT = "error_semantico";
                            }else{
                                if (partes_valor2[1].equals("var")){
                                    String tipo = buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), partes_valor2[0], "id");
                                    if(tipo == null){
                                        //Manejo error semántico
                                        errores = true;
                                        manejoError(" El parametro: '"+ partes_valor2[0] +"' es de un variable la cual no ha sido definida previamente, dentro de "+currentHash, "semántico");
                                        RESULT = "error_semantico";
                                    }else {
                                        if(!tipo.equals("int")){
                                            //Manejo error semántico
                                            errores = true;
                                            manejoError(" El parametro: '"+ partes_valor2[0] +"' el tipo de dato de la variable no es correcto, dentro de "+currentHash, "semántico");
                                            RESULT = "error_semantico";
                                        }
                                    }
                                }
                            }
                            if(!errores){ 
                                RESULT = partes_valor[0]+": " + "1".toString()+": " + partes_valor2[0]; 
                            }
                        :};
PARAMFORRANGETRES   ::= VALORESARIT:param1 ENDLINE VALORESARIT:param2 ENDLINE VALORESARIT:param3   
                        {:  
                            String[] partes_valor = param1.toString().split(": ");
                            String[] partes_valor2 = param2.toString().split(": ");
                            String[] partes_valor3 = param3.toString().split(": ");
                            boolean errores = false;
                            if ((!partes_valor[1].equals("int")) && (!partes_valor[1].equals("var"))){
                                //Manejo error semántico
                                errores = true;
                                manejoError(" El parametro: '"+ partes_valor[0] +"' es de un tipo incorrecto para un parametro del 'forRange', dentro de "+currentHash, "semántico");
                                RESULT = "error_semantico";
                            }else{
                                if (partes_valor[1].equals("var")){
                                    String tipo = buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), partes_valor[0], "id");
                                    if(tipo == null){
                                        //Manejo error semántico
                                        errores = true;
                                        manejoError(" El parametro: '"+ partes_valor[0] +"' es de un variable la cual no ha sido definida previamente, dentro de "+currentHash, "semántico");
                                        RESULT = "error_semantico";
                                    }else {
                                        if(!tipo.equals("int")){
                                            //Manejo error semántico
                                            errores = true;
                                            manejoError(" El parametro: '"+ partes_valor[0] +"' el tipo de dato de la variable no es correcto, dentro de "+currentHash, "semántico");
                                            RESULT = "error_semantico";
                                        }
                                    }
                                }
                            }
                            //validaciones param2
                            if ((!partes_valor2[1].equals("int")) && (!partes_valor2[1].equals("var"))){
                                //Manejo error semántico
                                errores = true;
                                manejoError(" El parametro: '"+ partes_valor2[0] +"' es de un tipo incorrecto para un parametro del 'forRange', dentro de "+currentHash, "semántico");
                                RESULT = "error_semantico";
                            }else{
                                if (partes_valor2[1].equals("var")){
                                    String tipo = buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), partes_valor2[0], "id");
                                    if(tipo == null){
                                        //Manejo error semántico
                                        errores = true;
                                        manejoError(" El parametro: '"+ partes_valor2[0] +"' es de un variable la cual no ha sido definida previamente, dentro de "+currentHash, "semántico");
                                        RESULT = "error_semantico";
                                    }else {
                                        if(!tipo.equals("int")){
                                            //Manejo error semántico
                                            errores = true;
                                            manejoError(" El parametro: '"+ partes_valor2[0] +"' el tipo de dato de la variable no es correcto, dentro de "+currentHash, "semántico");
                                            RESULT = "error_semantico";
                                        }
                                    }
                                }
                            }
                            //validaciones param3
                            if ((!partes_valor3[1].equals("int")) && (!partes_valor3[1].equals("var"))){
                                //Manejo error semántico
                                errores = true;
                                manejoError(" El parametro: '"+ partes_valor3[0] +"' es de un tipo incorrecto para un parametro del 'forRange', dentro de "+currentHash, "semántico");
                                RESULT = "error_semantico";
                            }else{
                                if (partes_valor3[1].equals("var")){
                                    String tipo = buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), partes_valor3[0], "id");
                                    if(tipo == null){
                                        //Manejo error semántico
                                        errores = true;
                                        manejoError(" El parametro: '"+ partes_valor3[0] +"' es de un variable la cual no ha sido definida previamente, dentro de "+currentHash, "semántico");
                                        RESULT = "error_semantico";
                                    }else {
                                        if(!tipo.equals("int")){
                                            //Manejo error semántico
                                            errores = true;
                                            manejoError(" El parametro: '"+ partes_valor3[0] +"' el tipo de dato de la variable no es correcto, dentro de "+currentHash, "semántico");
                                            RESULT = "error_semantico";
                                        }
                                    }
                                }
                            }
                            if(!errores){ 
                                RESULT = partes_valor[0]+": " + partes_valor2[0] +": " + partes_valor3[0]; 
                            }
                        :};
PARAMFORRANGE       ::= PARAMFORRANGEUNO:params {: RESULT = params; :}
                        | PARAMFORRANGEDOS:params {: RESULT = params; :}
                        | PARAMFORRANGETRES:params {: RESULT = params; :};

CONDICIONALFOR      ::= PARAMFORRANGE:params {: 
                            if(params.equals("error_semantico")){
                                RESULT = params;
                            }else{
                                System.out.println(params);
                            }
                        :};

ESTRUCTFORRANGE     ::= INICIOFOR RESERVFORRANGE:resv SIGABREPARENT CONDICIONALFOR SIGCIERRAPARENT SIGABRELLAVES BLOQUECODIGO SIGCIERRALLAVES;
INICIOFOR           ::= {: 
                            String tipoTabla = "tipo:ciclo:for";
                            ArrayList<String> listaSimbolos = new ArrayList<String>();
                            fatherCurrentHash = currentHash;
                            currentHash = "for_"+(++contador_for)+"_"+fatherCurrentHash;
                            listaSimbolos.add(tipoTabla);
                            hashTree.addLast(currentHash);
                            currentHashPos++;
                            listaTablaSimbolos.put(currentHash, listaSimbolos);
                            codIn3D.append("\n_begin_for_"+(contador_for)+":");
                        :} ;

ESTRUCTWHILE        ::= RESERVWHILE CONDICIONES SIGABRELLAVES BLOQUECODIGO SIGCIERRALLAVES 
                        | RESERVWHILE CONDICIONES SIGABRELLAVES BLOQUECODIGO SIGCIERRALLAVES ESTRUCTELSE;

LITERAL             ::= LITINT:litInt {: RESULT = litInt.toString()+": "+"int"; :}
                        | LITFLOAT:litfloat {: RESULT = litfloat.toString()+": "+"float"; :}
                        | LITCHAR:litchar {: RESULT = litchar+": "+"char"; :}
                        | LITSTRING:litstring {: RESULT = litstring+": "+"string"; :};

CASE                ::= RESERVCASE SEPARADOR LITERAL DOSPUNTOS BLOQUECODIGO SENTBREAK;
CASES               ::= CASE | CASE CASES;
DEFAULT             ::= RESERVDEFAULT DOSPUNTOS BLOQUECODIGO SENTBREAK;
ESTRUCTSWITCH       ::= RESERVSWITCH SIGABREPARENT IDENTIFICADOR SIGCIERRAPARENT SIGABRELLAVES CASES DEFAULT SIGCIERRALLAVES;

TIPOSPARAM          ::= TIPOINT {: RESULT = "int";:} 
                        | TIPOFLOAT {: RESULT = "float";:} 
                        | TIPOBOOL {: RESULT = "bool";:}
                        | TIPOCHAR {: RESULT = "char";:};
PARMFUNC            ::= TIPOSPARAM:tip SEPARADOR IDENTIFICADOR:id ;
                        
PARAMETROFUNCION    ::= PARMFUNC
                        | PARMFUNC COMA PARAMETROFUNCION;
PARAMFUNCIONES      ::= SIGABREPARENT PARAMETROFUNCION SIGCIERRAPARENT
                        | SIGABREPARENT SIGCIERRAPARENT;
FUNCMAIN            ::=  INIFUNMAIN PARAMFUNCIONES SIGABRELLAVES BLOQUECODIGO SIGCIERRALLAVES
                {:  
                    codIn3D.append("\n_main_end:"); 
                    hashTree.removeLast(); 
                :};

INIFUNMAIN          ::=TIPOINT:tip SEPARADOR RESERVMAIN:id
                {:
                    String tipoTabla;
                    if(id.toString().equals("main")){
                     tipoTabla = "tipo:funcion:"+id.toString()+": "+tip.toString();
                    }
                    else{
                     tipoTabla = "tipo:funcion:"+id.toString()+": "+tip.toString();
                    }
                    if(existeFuncion(id.toString()) == null){
                         ArrayList<String> listaSimbolos = new ArrayList<String>();
                         currentHash = id.toString();
                         listaSimbolos.add(tipoTabla);
                         hashTree.addLast(currentHash);
                         listaTablaSimbolos.put(currentHash, listaSimbolos);
                         RESULT = tip.toString()+" "+id.toString();
                         codIn3D.append("\n_"+id.toString()+"_begin:");
                         mipsMain.append("\n"+id.toString()+":");
                    }
                    else{
                         currentHash = id.toString();
                         hashTree.addLast(currentHash);
                         manejoError("Función "+id.toString()+" ya existe", "semántico");
                    }
                :}; 

CREAFUNC            ::= INIFUN PARAMFUNCIONES SIGABRELLAVES BLOQUECODIGO SIGCIERRALLAVES
                {:  
                    codIn3D.append("\n_"+hashTree.getLast()+"_end:"); 
                    hashTree.removeLast(); 
                :};

TIPORETORNO         ::= TIPOINT {: RESULT = "int";:}
                        | TIPOFLOAT {: RESULT = "float";:}
                        | TIPOBOOL {: RESULT = "bool";:};

INIFUN              ::= TIPORETORNO:tip IDENTIFICADOR:id
                {:
                    String tipoTabla = "tipo:funcion:"+id.toString()+": "+tip.toString();
                    if((!(tip.toString().equals("int"))) && (!(tip.toString().equals("float"))) && (!(tip.toString().equals("bool")))){
                        currentHash = id.toString();
                        hashTree.addLast(currentHash);
                        manejoError("El tipo de dato de retorno de la función "+id.toString()+" no es valido", "semántico");
                    }else{
                        if(existeFuncion(id.toString()) == null){
                             ArrayList<String> listaSimbolos = new ArrayList<String>();
                             currentHash = id.toString();
                             listaSimbolos.add(tipoTabla);
                             hashTree.addLast(currentHash);
                             listaTablaSimbolos.put(currentHash, listaSimbolos);
                             RESULT = tip.toString()+" "+id.toString();
                             codIn3D.append("\n_"+id.toString()+"_begin:");
                             mipsMain.append("\n"+id.toString()+":");
                        }
                        else{
                             currentHash = id.toString();
                             hashTree.addLast(currentHash);
                             manejoError("Función "+id.toString()+" ya existe", "semántico");
                        }
                    }
                :}; 


PARAMLLAMARFUNC     ::= LITINT:litInt {: RESULT = litInt.toString()+": "+"int"; :}
                        | LITFLOAT:litfloat {: RESULT = litfloat.toString()+": "+"float"; :}
                        | LITCHAR:litchar {: RESULT = litchar+": "+"char"; :}
                        | LITBOOL:litbool {: RESULT = litbool+": "+"bool"; :}
                        | IDENTIFICADOR:id {: RESULT = id; :}
                        | LLAMARFUNC;

                       

PARAMLLAMAFUNC      ::= PARAMLLAMARFUNC | PARAMLLAMARFUNC COMA PARAMLLAMAFUNC;
LLAMARFUNC          ::= IDENTIFICADOR SIGABREPARENT PARAMLLAMAFUNC SIGCIERRAPARENT ; 
LLAMARFUNC          ::= IDENTIFICADOR SIGABREPARENT SIGCIERRAPARENT ;
SENTLLAMARFUNC      ::= LLAMARFUNC ENDLINE;

SENTENCIA           ::= VARIABLES 
                        | FUNCLEER 
                        | FUNCESCRIBIR ;
ESTRUCTCONTROL      ::= ESTRUCTIF
                        | ESTRUCTSWITCH 
                        | ESTRUCTFORRANGE 
                        | ESTRUCTWHILE;
VALORESBLOQUECODIGO ::= SENTENCIA 
                        | ESTRUCTCONTROL 
                        | RESERVBREAK ENDLINE 
                        | SENTRETURN 
                        | SENTLLAMARFUNC;

GLOBALVAR           ::= CREAVARINT 
                        | CREAASIGVARINT 
                        | CREAVARFLOAT 
                        | CREAASIGVARFLOAT 
                        | CREAVARBOOL 
                        | CREAASIGVARBOOL 
                        | CREAVARCHAR 
                        | CREAASIGVARCHAR 
                        | CREAVARSTRING 
                        | CREAASIGVARSTRING;
VALORPROGRAMA       ::= CREAFUNC 
                        | GLOBALVAR 
                        | COMENTARIOS;
VALORESPROGRAMA     ::= VALORPROGRAMA VALORESPROGRAMA;
PROGRAMA            ::= FUNCMAIN
                        | FUNCMAIN VALORESPROGRAMA
                        | VALORESPROGRAMA FUNCMAIN
                        | VALORESPROGRAMA FUNCMAIN
                        VALORESPROGRAMA;

INICIO              ::= PROGRAMA {: /*imprimirTablaSimbolos();*/ imprimirCodigo3D(); imprimirCodigoMIPS();:};