package sintaxis;

import java_cup.runtime.*;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Collection;

// Aquí va la gramática BNF que hicimos solo que se pone con ::= en vez de la flecha 
// También se declaran los terminales y los no terminales por medio de los símbolos y las producciones

// CODIGO JAVA 

action code {:
    LexerCup lex;
    private Object symbolFactory;
    Symbol token;
    Boolean errores = false;
    HashMap<String, ArrayList<String>> listaTablaSimbolos = new HashMap<String, ArrayList<String>>();
    String currentHash;
    int currentTemp = 0;
    StringBuilder codIn3D = new StringBuilder();
    ArrayList<String> elementosArray = new ArrayList<>();
    ArrayList<String> elementosParametros = new ArrayList<>();
    int contador_for = 0;
    int contador_while = 0;
    int contador_if = 0;
    int contador_fin_if = 1;
    int contador_if_anidados = 0;
    int contador_else = 0;
    int contador_fin_for = 1;
    int contador_for_anidados =0;
    int contador_case = 0;
    int contador_switch = 0;
    String tipoSwitch = "";
    String varSwitch = "";
    String fatherCurrentHash = null;
    LinkedList<String> hashTree = new LinkedList<>();
    int currentHashPos = 0;
    StringBuilder mipsData = new StringBuilder();
    StringBuilder mipsMain = new StringBuilder();
    StringBuilder mipsFunciones = new StringBuilder();
    String stringCreationMips = "";
    int mipsTemp = 0;
    boolean existeOpeArit = false;
    boolean existeOpeRela = false;
    int bandera = 0;


    public String existeFuncion(String idBuscado){
        Collection<ArrayList<String>> valores = listaTablaSimbolos.values();
        for (ArrayList<String> tablaSimbolos : valores){
            for (String elemento : tablaSimbolos) {
                // Divide el elemento en ID y tipo
                String[] partes = elemento.split(":");
                if (partes[0].equals("tipo") && partes[2].equals(idBuscado)) { // Verifica si el ID coincide con el ID buscado
                    return partes[3].trim(); // Se encontró el ID de la función y se envía el tipo de la función
                }
            }
        }
        return null;   
    }

    /* Constructor del parser, recibe como parámetro el lexer que se va a utilizar 
        Entradas: Lexer lex
        Salidas: Ninguna
        Restricciones: Ninguna
    */

    @SuppressWarnings("deprecation")
    public void parser(LexerCup lex){
        this.lex = lex;
        this.symbolFactory = new DefaultSymbolFactory();
    }
    
    /* Método que se encarga de retornar el valor booleao de errores. Indicando si hubo errores o no
        Entradas: Ninguna
        Salidas: errores
        Restricciones: Ninguna
    */
    public boolean getErrores(){
        return errores;
    }

    /* Método que se encarga de retornar el string buffer del código intermedio 3 direcciones
        Entradas: Ninguna
        Salidas: codIn3D
        Restricciones: Ninguna
    */
    public StringBuilder getCodIn3D(){
        return codIn3D;
    }

    /*
        Método que se encarga de retornar el string buffer del código MIPS
        Entradas: Ninguna
        Salidas: mipsData
        Restricciones: Ninguna
    */
    public StringBuilder getMipsData(){
        return mipsData;
    }

    /*
        Método que se encarga de retornar el string buffer del código MIPS
        Entradas: Ninguna
        Salidas: mipsMain
        Restricciones: Ninguna
    */
    public StringBuilder getMipsFunciones(){
        return mipsFunciones;
    }

    /*
        Método que se encarga de retornar el string buffer del código MIPS
        Entradas: Ninguna
        Salidas: mipsMain
        Restricciones: Ninguna
    */
    public StringBuilder getMipsMain(){
        return mipsMain;
    }
    /* Método que se encarga de imprimir la tabla de símbolos
        Entradas: Ninguna
        Salidas: Ninguna
        Restricciones: Ninguna
    */
    private void imprimirTablaSimbolos(){
        for(String key: listaTablaSimbolos.keySet()){
            System.out.println("-------------------------");
            System.out.println("Tabla de símbolos: "+key);
            System.out.println("Valores: ");
            for(String item: listaTablaSimbolos.get(key)){
                System.out.println(item);
            }
            System.out.println("");
        }
    }

     /* Método que se encarga de imprimir el string buffer del código intermedio 3 direcciones en la terminal.
        Entradas: Ninguna
        Salidas: Ninguna
        Restricciones: Ninguna
    */
    private void imprimirCodigo3D(){
        System.out.println("++++++++ CODIGO 3D +++++++++");
        System.out.println("");
        System.out.println(codIn3D.toString());
    }


    /* Método que se encarga de imprimir el string buffer del código MIPS en la terminal.
        Entradas: Ninguna
        Salidas: Ninguna
        Restricciones: Ninguna
    */
    private void imprimirCodigoMIPS(){
        System.out.println("++++++++ CODIGO MIPS +++++++++");
        System.out.println("");
        System.out.println(".data\n");
        System.out.println(mipsData.toString());
        System.out.println(".text\n");
        System.out.println(".globl main\n");
        System.out.println(mipsFunciones.toString());
        System.out.println(mipsMain.toString());
        System.out.println("   li $v0, 10");
        System.out.println("   syscall");
    }

    /* Método que se encarga de imprimir el string buffer del código MIPS en un archivo .asm.
        Entradas: Ninguna
        Salidas: Ninguna
        Restricciones: Ninguna
    */
    private int addMipsTemp(){
        if (mipsTemp == 9){
            mipsTemp = 0;
        }else{
            mipsTemp++;
        }
        return mipsTemp;
    }

    /*
        Método que se encarga de retornar la tabla de símbolos
        Entradas: Ninguna
        Salidas: tabla de símbolos
        Restricciones: Ninguna
    */
    public HashMap<String, ArrayList<String>> getTablaSimbolos(){
        return listaTablaSimbolos;
    }

    /* Método que se encarga de imprimir en consola el error sintáctico
        Entradas: String error. Error que se va a imprimir
        Salidas: Ninguna. Imprime en consola el error
        Restricciones: Ninguna
    */
    private void manejoError(String error, String tipoError){
        errores = true;
        System.out.println("Error "+tipoError+": "+ error );
        System.out.println("Se continua con el análisis "+tipoError);
    } 

    /* Método que se encarga de buscar en la tabla de símbolos actual un ID y devolver su tipo.
        Entradas: lista: lista de elementos de la tabla de símbolos actual, idBuscado: ID que se requiere buscar y queBusca: si busca el ID de una variable o de una función. 
        Salidas: String o null
        Restricciones: Ninguna
    */
     private String buscarID_o_tipoID(ArrayList<String> tablaSimbolos, String idBuscado, String queBusca) {
        int treeSize = hashTree.indexOf(hashTree.get(currentHashPos));
        for (int i = treeSize; i >= 0; i--) {
            tablaSimbolos = listaTablaSimbolos.get(hashTree.get(i));
            if(queBusca.equals("id")){
                // Recorre los elementos del ArrayList
                for (String elemento : tablaSimbolos) {
                    // Divide el elemento en ID y tipo
                    String[] partes = elemento.split(": ");
                    if (partes[0].equals(idBuscado)) { // Verifica si el ID coincide con el ID buscado
                        return partes[1]; // Se encontró el ID y se envía el tipo del ID
                    }
                    if (partes[0].equals("Parámetro") && partes[1].equals(idBuscado)) { // Verifica si el ID coincide con el ID buscado
                        return partes[2].trim(); // Se encontró el ID y se envía el tipo del ID
                    }	
                }
            }
            else if(queBusca.equals("funcion")){
                // Recorre los elementos del ArrayList
                for (String elemento : tablaSimbolos) {
                    // Divide el elemento en ID y tipo
                    String[] partes = elemento.split(":");
                
                    if (partes[1].equals(idBuscado)) { // Verifica si el ID coincide con el ID buscado
                        return partes[2]; // Se encontró el ID de la función y se envía el tipo de la función
                    }
                }
            }
            else if(queBusca.equals("tamañoArray")){
                // Recorre los elementos del ArrayList
                for (String elemento : tablaSimbolos) {
                    // Divide el elemento en ID y tipo
                    String[] partes = elemento.split(": ");
                
                    if (partes[0].equals(idBuscado)) { // Verifica si el ID coincide con el ID buscado
                        return partes[2]; // Se encontró el ID de la función y se envía el tipo de la función
                    }
                }

            }
        }
        return null;       
    }

    private ArrayList<String> obtenerParametrosFuncion(String funcion){
        Collection<ArrayList<String>> valores = listaTablaSimbolos.values();
        ArrayList<String> parametros = new ArrayList<String>();
        for (ArrayList<String> tablaSimbolos : valores){
            // Recorre los elementos del ArrayList
            for (int i = 0; i < tablaSimbolos.size(); i++) {
                String elemento = tablaSimbolos.get(i);
                // Divide el elemento en ID y tipo
                String[] partes = elemento.split(":");
                if (partes[0].equals("tipo") && partes[2].equals(funcion)) { // Verifica si el ID coincide con el ID buscado
                    for (int j = i+1; j < tablaSimbolos.size(); j++){
                        String linea = tablaSimbolos.get(j); // Se encontró el ID de la función y se envía el tipo de la función
                        if(linea.contains("Parámetro")){
                            parametros.add(linea);
                        }
                    }
                    if (parametros.size() != 0){
                        return parametros;
                    }
                }
            }
        }
        return null;   
    }
    
    /*  Método que se encarga de realizar las operaciones aritmeticas
        Entradas: Dos operando y un operador de tipo String 
        Salidas: 
        Restricciones: Ninguna
    */
    private void ejecutaOpeArit (String operacion){
        operacion = operacion.substring(1,operacion.length()-1);
        String[] operaTemp = operacion.split("'");
        String operando1 = "";
        String operando2 = "";
        String operador = "";
        String instruccionMips = "";
        String instruccion3D = "";
        int pos = 0;
        int contParent = 0;
        String temp = "";
        for(String cadena:operaTemp){
            for(int i = 0; i < cadena.length();i++){
                if(cadena.charAt(i) == '('){
                    contParent++;
                }
            }
            if(cadena.charAt(cadena.length()-1) == ')'){
                temp += "'" + cadena;
                contParent--;
            }else{
                if(cadena.charAt(0) == '('){
                    temp += cadena + "'";
                }else{
                    temp += cadena;
                }
            }
            if(contParent <= 0){
                contParent = 0;
                switch(pos){
                    case 0:
                        operando1 = temp;
                        temp = "";
                        pos = 1;
                        break;
                    case 1:
                        operador = cadena;
                        temp = "";
                        pos = 2;
                        break;
                    default:
                        operando2 = temp;
                        temp = "";
                        contParent = 0;
                        break;
                }
            }
        }        
        
        if (operando1.charAt(0)=='('){ 
           ejecutaOpeArit(operando1);
           //Codigo Mips
           instruccionMips += ("\n   move $t8, $t0");  
           instruccion3D += ("\n t8 = t1");
        }else{
            if (buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), operando1, "id") == null){
                instruccionMips += ("\n   li $t8, "+ operando1);
                instruccion3D += ("\n t8 = "+ operando1);                                        
            }else{
                instruccionMips += ("\n   lw $t8, "+ operando1);
                instruccion3D += ("\n t8 = "+ operando1);                                        
            }
        }

        if (operando2.charAt(0)==('(')){ 
           ejecutaOpeArit(operando2);
           //Codigo Mips
           instruccionMips += ("\n   move $t9, $t0");
           instruccion3D += ("\n t9 = t1");
        }else{
            if (buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), operando2, "id") == null){
                instruccionMips += ("\n   li $t9, "+ operando2);
                instruccion3D += ("\n t9 = "+ operando2);                                        
            }else{
                instruccionMips += ("\n   lw $t9, "+ operando2);
                instruccion3D += ("\n t9 = "+ operando2);                                        
            }
        }
        
        instruccionMips += ("\n   move $a0, $t8 \n   move $a1, $t9 \n   move $a2, " + operador + "\n   jal calculate");
        instruccion3D += "\n t7 = " + operador +  "\n t1 = call calculation(t8,t9,t7)"; 
        
        mipsMain.append(instruccionMips);
        codIn3D.append(instruccion3D);
    }

  /*  Método que se encarga de realizar las operaciones relacionales
        Entradas: Dos operando y un operador de tipo String 
        Salidas: 
        Restricciones: Ninguna
    */
    private void ejecutaOpeRela (String operacion, String sigNegacion){
        operacion = operacion.substring(1,operacion.length()-1);
        String[] operaTemp = operacion.split("'");
        String operando1 = "";
        String operando2 = "";
        String operador = "";
        String instruccionMips = "";
        String instruccion3D = "";
        int pos = 0;
        int contParent = 0;
        String temp = "";
        for(String cadena:operaTemp){
            for(int i = 0; i < cadena.length();i++){
                if(cadena.charAt(i) == '['){
                    contParent++;
                }
            }
            if(cadena.charAt(cadena.length()-1) == ']'){
                temp += "'" + cadena;
                contParent--;
            }else{
                if(cadena.charAt(0) == '['){
                    temp += cadena + "'";
                }else{
                    temp += cadena;
                }
            }
            if(contParent <= 0){
                contParent = 0;
                switch(pos){
                    case 0:
                        operando1 = temp;
                        temp = "";
                        pos = 1;
                        break;
                    case 1:
                        operador = cadena;
                        temp = "";
                        pos = 2;
                        break;
                    default:
                        operando2 = temp;
                        temp = "";
                        contParent = 0;
                        break;
                }
            }
        }        
        
        if (operando1.charAt(0)=='['){ 
           ejecutaOpeRela(operando1,sigNegacion);
           //Codigo Mips
           instruccionMips += ("\n   move $t8, $t0");  
           instruccion3D += ("\n t8 = t1");
        }else{
            if (buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), operando1, "id") == null){
                instruccionMips += ("\n   li $t8, "+ operando1);
                instruccion3D += ("\n t8 = "+ operando1);                                        
            }else{
                instruccionMips += ("\n   lw $t8, "+ operando1);
                instruccion3D += ("\n t8 = "+ operando1);                                        
            }
        }

        if (operando2.charAt(0)==('[')){ 
           ejecutaOpeRela(operando2,sigNegacion);
           //Codigo Mips
           instruccionMips += ("\n   move $t9, $t0");
           instruccion3D += ("\n t9 = t1");
        }else{
            if (buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), operando2, "id") == null){
                instruccionMips += ("\n   li $t9, "+ operando2);
                instruccion3D += ("\n t9 = "+ operando2);                                        
            }else{
                instruccionMips += ("\n   lw $t9, "+ operando2);
                instruccion3D += ("\n t9 = "+ operando2);                                        
            }
        }

        instruccionMips += ("\n   move $a0, $t8 \n   move $a1, $t9 \n   move $a2, " + operador + "\n   jal calculate");
        if (sigNegacion.equals("!")){
            instruccion3D += "\n t2 = t8 " + operador +" t9 \n t1 = !t2" ; 
        }else{
            instruccion3D += "\n t1 = t8 " + operador +" t9" ; 
        }
        mipsMain.append(instruccionMips);
        codIn3D.append(instruccion3D);
    }



    private void condicionWhile (){
        if (bandera == 1){
            codIn3D.append("\n  if t1 goto bloque_if" + contador_if);
            codIn3D.append("\n  goto end_fin_" + contador_if);
            codIn3D.append("\nbloque_if" + contador_if + ":");
        }else{
            codIn3D.append("\n  if t1 goto bloque_while" + contador_while);
            codIn3D.append("\n  goto end_while_" + contador_while);
            codIn3D.append("\nbloque_while" + contador_while + ":");
            }
    }


:}




parser code {:
:}



//------------------------------------------------------------------------------------------------
terminal        ENDLINE,SEPARADOR,DOSPUNTOS,COMA,SIGNOIGUAL,SIGRESTA,SIGSUMA,SIGMULTI,SIGDIV,SIGMOD,SIGPOT,
                SIGCONJUNCION,SIGDISYUNCION,SIGNEGACION,SIGAUMEN,SIGDIMINU,SIGMENOR,SIGMENORIGUAL,SIGMAYOR,SIGMAYORIGUAL,IGUAL,SIGDIFERENTE,SIGABREPARENT,
                SIGCIERRAPARENT,SIGABRELLAVES,SIGCIERRALLAVES,LITTRUE,LITFALSE,TIPOINT,TIPOFLOAT,TIPOBOOL,TIPOCHAR,TIPOSTRING,RESERVLEER,
                RESERVESCRIBIR,RESERVIF,RESERVELSE,RESERVSWITCH,RESERVWHILE,RESERVFORRANGE,RESERVMAIN,RESERVBREAK,RESERVRETURN,
                RESERVCASE,RESERVDEFAULT,LITINT,LITFLOAT,LITCHAR,LITSTRING,IDENTIFICADOR,COMENTARIOSIMPLE,COMENTARIOMULTIPLE;

non terminal    LITBOOL,OPERADORESARITME,OPERADORESLOGICOS,OPERADORESUNARIOS,OPERADORESRELA,COMENTARIOS,DATOSRETORNO,                
                SENTRETURN,OPERAUNARIA,OPERACIONUNARIA,VALORESARIT,OPERACIONARIT,ASIGNVAR,CREAVARINT,CREAASIGVARINT,                
                VARIABLESINT,CREAVARFLOAT,CREAASIGVARFLOAT,VARIABLESFLOAT,VALORESBOOL,PARAMETROFUNCION,FINIF, INICIOIF,   
                CREAVARBOOL,CREAASIGVARBOOL,VARIABLESBOOL,VALORESCHAR,CREAVARCHAR,CREAASIGVARCHAR,VARIABLESCHAR,                
                VALORESSTRING,CREAVARSTRING,CREAASIGVARSTRING,VARIABLESSTRING,VARIABLES,FUNCLEER,FUNCESCRIBIRINT,                
                FUNCESCRIBIRFLOAT,FUNCESCRIBIRSTRING,FUNCESCRIBIRID,FUNCESCRIBIR,OPERADORESBOOL,OPERANDOBOOLEANO,OPERACIONBOOL,
                OPERACIONRELAARIT,OPERANDOSLOGICOS,OPERACIONLOGICAS,CONDICIONES,SENTENCIA,ESTRUCTCONTROL,VALORESBLOQUECODIGO,                
                BLOQUECODIGO,ESTRUCTELSE,ESTRUCTIF,PARAMFORRANGEUNO,PARAMFORRANGEDOS,PARAMFORRANGETRES,PARAMFORRANGE,ESTRUCTFORRANGE,                
                ESTRUCTWHILE,LITERAL,CASE,CASES,DEFAULT,ESTRUCTSWITCH,TIPOSPARAM,PARAMFUNCIONES,FUNCMAIN,CREAFUNC,CONDICIONALFOR,                
                PARMFUNC,PARAMLLAMARFUNC,PARAMLLAMAFUNC,LLAMARFUNC,SENTLLAMARFUNC,GLOBALVAR,VALORPROGRAMA,INIFUN,VALORESPROGRAMA,               
                PROGRAMA,INICIO,VALORESCONDI,INIFUNMAIN,INICIOFOR,TIPORETORNO,INISWITCH,INICASE,INIDEFAULT, INIWHILE, CONDIWHILE, CONDIIF;

precedence left TIPOINT , TIPOFLOAT , TIPOBOOL , TIPOCHAR ;
precedence left SIGCONJUNCION, SIGDISYUNCION;

start with INICIO;

LITBOOL             ::= LITTRUE {: RESULT = "true"+": "+"bool"; :}
                        | LITFALSE {: RESULT = "false"+": "+"bool"; :};

OPERADORESARITME    ::= SIGRESTA {: RESULT = "-";:} 
                        | SIGSUMA {: RESULT = "+";:} 
                        | SIGMULTI {: RESULT = "*";:} 
                        | SIGDIV {: RESULT = "/";:} 
                        | SIGMOD {: RESULT = "%";:} 
                        | SIGPOT{: RESULT = "^";:};

OPERADORESLOGICOS   ::= SIGCONJUNCION {: RESULT = "&";:} 
                        | SIGDISYUNCION{: RESULT = "|";:};

OPERADORESUNARIOS   ::= SIGAUMEN {: RESULT = "++";:} 
                        | SIGDIMINU {: RESULT = "--";:};

COMENTARIOS         ::= COMENTARIOSIMPLE | COMENTARIOMULTIPLE;

DATOSRETORNO        ::= LITINT:litInt {: RESULT = litInt.toString()+": "+"int"; :}
                        | LITFLOAT:litfloat {: RESULT = litfloat.toString()+": "+"float"; :} 
                        | LITBOOL:litbool {: RESULT = litbool.toString()+": "+"bool"; :}  
                        | IDENTIFICADOR : id {: RESULT = id+": "+"var"; :}
                        | LLAMARFUNC ;
SENTRETURN          ::= RESERVRETURN SEPARADOR DATOSRETORNO ENDLINE;

OPERAUNARIA         ::= IDENTIFICADOR OPERADORESUNARIOS;
OPERAUNARIA         ::= OPERADORESUNARIOS IDENTIFICADOR ;
OPERACIONUNARIA     ::= OPERAUNARIA ENDLINE;

VALORESARIT         ::= LITINT:litInt {: RESULT = litInt.toString()+": "+"int"; :}
                        | LITFLOAT:litfloat {: RESULT = litfloat.toString()+": "+"float"; :}
                        | IDENTIFICADOR : id {: RESULT = id+": "+"var"; :} 
                        | LLAMARFUNC 
                        | OPERAUNARIA;       
                 
OPERACIONARIT       ::= VALORESARIT:valor {:RESULT = valor ;:}
                        | VALORESARIT:valor1 OPERADORESARITME:sig OPERACIONARIT:valor2 
                    {:
                        if ((valor1.equals("error_semantico")) || (valor2.equals("error_semantico"))){
                            RESULT = "error_semantico";
                        }else{
                            String[] partes_valor1 = valor1.toString().split(": ");
                            String[] partes_valor2 = valor2.toString().split(": ");
                            boolean errores = false;
                            if(partes_valor1[1].equals("var") || partes_valor2[1].equals("var")){
                                String tipo1 = buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), partes_valor1[0], "id");
                                String tipo2 = buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), partes_valor2[0], "id");
                                if (tipo1==null && tipo2==null){
                                    if(partes_valor2[1].equals("var") && (!partes_valor1[1].equals("var"))){
                                        manejoError("'" + partes_valor1[0] + " " + sig + " " + partes_valor2[0] + "' El la variable '"+ partes_valor2[0] +"' no ha sido creada previamente, dentro de "+currentHash, "semántico");
                                        RESULT = "error_semantico"; 
                                        errores = true;
                                    }else { if(!partes_valor2[1].equals("var") && (partes_valor1[1].equals("var"))){
                                        manejoError("'" + partes_valor1[0] + " " + sig + " " + partes_valor2[0] + "' El la variable '"+ partes_valor1[0] +"' no ha sido creada previamente, dentro de "+currentHash, "semántico");
                                        RESULT = "error_semantico"; 
                                        errores = true;
                                    } else {
                                        manejoError("'" + partes_valor1[0] + " " + sig + " " + partes_valor2[0] + "' Las variables: '"+ partes_valor1[0] +"' y " + partes_valor2[0] + " no han sido creadas previamente, dentro de "+currentHash, "semántico");
                                        RESULT = "error_semantico"; 
                                        errores = true;
                                    }}
                                }else {if (tipo1!=null && tipo2!=null){
                                    if(!tipo1.equals(tipo2)){
                                        manejoError("'" + partes_valor1[0] + " " + sig + " " + partes_valor2[0] + "' Las variables de los operadores no son del mismo tipo, una de tipo '" + partes_valor1[1] + "' y la otra de tipo '" + partes_valor1[1] + "', dentro de "+currentHash, "semántico");errores = true;
                                        RESULT = "error_semantico"; 
                                        errores = true;
                                    }
                                }else{ if (tipo1==null && tipo2!=null){
                                    if(!partes_valor1[1].equals(tipo2)){
                                        manejoError("'" + partes_valor1[0] + " " + sig + " " + partes_valor2[0] + "' El la variable '"+ partes_valor2[0] +"', debe ser de tipo tipo:'" + partes_valor1[1] + "', dentro de "+currentHash, "semántico");
                                        RESULT = "error_semantico"; 
                                        errores = true;
                                    }
                                }else{if (tipo2==null && tipo1!=null){
                                    if(!partes_valor2[1].equals(tipo1)){
                                        manejoError("'" + partes_valor1[0] + " " + sig + " " + partes_valor2[0] + "' El la variable '"+ partes_valor1[0] +"', debe ser de tipo tipo:'" + partes_valor2[1] + "', dentro de "+currentHash, "semántico");
                                        RESULT = "error_semantico"; 
                                        errores = true;
                                    }
                                }}}}
                            }
                            if (!(partes_valor1[1].equals("float")) && (!partes_valor1[1].equals("int")) && (!partes_valor1[1].equals("var"))){
                                //Manejo error semántico
                                errores = true;
                                manejoError("'" + valor1 + " " + sig + " " + valor2 + "' El operador: "+ valor1 +" es de un tipo incorrecto para una operacion aritmetica, dentro de "+currentHash, "semántico");
                                RESULT = "error_semantico";
                            }
                            if (!(partes_valor2[1].equals("float")) && (!partes_valor2[1].equals("int")) && (!partes_valor2[1].equals("var"))){
                                //Manejo error semántico
                                errores = true;
                                manejoError("'" + valor1 + " " + sig + " " + valor2 + "' El operador: "+ valor2 +" es de un tipo incorrecto para una operacion aritmetica, dentro de "+currentHash, "semántico");
                                RESULT = "error_semantico";                               
                            }   
                            if (partes_valor1[1].equals(partes_valor2[1]) || partes_valor1[1].equals("var") || partes_valor2[1].equals("var")){
                                if (!errores){
                                    String tipo = "";
                                    if (partes_valor1[1].equals("var")&& (!partes_valor2[1].equals("var"))){
                                        tipo = partes_valor2[1];
                                    }else{
                                        if (partes_valor2[1].equals("var")&& (!partes_valor1[1].equals("var"))){
                                            tipo = partes_valor1[1];
                                        }else{
                                            if ((!partes_valor2[1].equals("var")) && (!partes_valor1[1].equals("var"))){
                                                tipo = partes_valor1[1];
                                            }else{
                                                tipo = buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), partes_valor1[0], "id");                                                
                                            }
                                        }
                                    }
                                    if (!existeOpeArit){
                                        // codigo Mips para operaciones
                                        mipsFunciones.append("calculate:\n  addi $sp, $sp, -12\n  sw $t0, 0($sp)\n  sw $a0, 4($sp)\n  sw $a1, 8($sp)\n  lw $t1, 4($sp)\n  lw $t2, 8($sp)\n  lb $t3, 12($sp)\n  beq $t3, '+', add_op\n  beq $t3, '-', sub_op\n  beq $t3, '*', mul_op\n  beq $t3, '/', div_op\n  beq $t3, '^', pow_op\n  beq $t3, '%', mod_op\nadd_op:\n  add $t0, $t1, $t2\n  j end_calculation\nsub_op:\n  sub $t0, $t1, $t2\n  j end_calculation\nmul_op:\n  mul $t0, $t1, $t2\n  j end_calculation\ndiv_op:\n  div $t1, $t2\n  mflo $t0\n  j end_calculation\npow_op:\n  \n  li $v0, 1 \n  move $t4, $t2   \n  power_loop:\n      beqz $t4, end_power  \n      mul $v0, $v0, $t1    \n      subi $t4, $t4, 1     \n      j power_loop\nend_power:\n  move $t0, $v0  \n  j end_calculation\nmod_op:\n  div $t1, $t2\n  mfhi $t0       \nend_calculation:\n  lw $t0, 0($sp)\n  addi $sp, $sp, 12\n  jr $ra");
                                        existeOpeArit = true;
                                    }
                                    if (!errores){
                                        String temp = "(" + partes_valor1[0] + "'" + sig + "'" + partes_valor2[0] +")";
                                        RESULT = temp + ": " + tipo; 
                                    }else{
                                        String temp = "(" + partes_valor1[0] + "'" + sig + "'" + partes_valor2[0] +")";
                                        RESULT = temp + ": err";
                                    }
                                }
                            }else{
                                //Manejo error semántico
                                manejoError("'" + valor1 + " " + sig + " " + valor2 + "' Los operadores no son del mismo tipo, dentro de "+currentHash, "semántico");
                                RESULT = "error_semantico";
                            }
                        }
                    :} 
                        | SIGABREPARENT OPERACIONARIT:valor1 SIGCIERRAPARENT {:RESULT = valor1 ;:};

ASIGNVAR            ::= IDENTIFICADOR:id SIGNOIGUAL OPERACIONARIT:op ENDLINE
                {:   // ++++ Análisis semántico ++++
                    String tip = buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id");
                    String ladoIzqTipo = tip;
                    String ladoIzqId = id.toString(); 
                    if (tip == null){
                        //Manejo error semántico
                        manejoError("El ID: "+ id +" no ha sido creado anteriormente", "semántico");
                        RESULT = "error_semantico";
                    }else{
                        if ((op.equals("error_semantico"))){
                            RESULT = "error_semantico";
                        }else{
                            String[] partes_op = op.toString().split(": ");
                            if((ladoIzqTipo.equals(partes_op[1].toString())) || (partes_op[1].toString().equals("var"))){
                                if(!(ladoIzqTipo.equals(partes_op[1].toString())) && buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), partes_op[0].toString(), "id") == null){
                                    //Manejo error semántico
                                    manejoError("'" + tip +" # "+ id + " = " + partes_op[0] + ";' " + "El ID: '"+ partes_op[0] +"' no ha sido creado anteriormente", "semántico");
                                    RESULT = "error_semantico";
                                }else{
                                    if (!(ladoIzqTipo.equals(partes_op[1])) && !(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), partes_op[0], "id").equals("int"))){
                                        //Manejo error semántico
                                        manejoError("'" + tip +" # "+ id + " = " + partes_op[0] + ";' " + "La variable: '"+ partes_op[0] +"' no es de tipo int", "semántico");
                                        RESULT = "error_semantico";
                                    }else{
                                        if(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null ) {
                                            String temp = "t"+(currentTemp++); 
                                            if (partes_op[0].charAt(0)=='('){
                                                listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                                                codIn3D.append("\ndataInt "+ladoIzqId);
                                                ejecutaOpeArit(partes_op[0]);
                                                mipsMain.append("\n   sw $t0, "+ id);

                                                codIn3D.append("\n"+ ladoIzqId +" = t1");
                                                mipsData.append("   " + ladoIzqId+": ."+"word 0"+"\n");

                                            }else{
                                                // ++++ Código 3D ++++
                                                //String temp = "t"+(currentTemp++); 
                                                if (currentTemp == 10){
                                                    currentTemp = 0;
                                                }
                                                codIn3D.append("\ndataInt "+ladoIzqId);
                                                codIn3D.append("\n"+ temp +" = "+partes_op[0].toString());                                        
                                                codIn3D.append("\n"+ ladoIzqId +" = "+temp);
                                                mipsData.append("   " + ladoIzqId+": ."+"word 0"+"\n");

                                                String mipsAsignation = "";
                                                if(partes_op[1].equals("var")){
                                                    mipsAsignation = "lw $"+temp+", "+ partes_op[0];
                                                }else{
                                                    mipsAsignation = "li $"+temp+", "+ partes_op[0];
                                                }
                                                mipsMain.append("\n   "+mipsAsignation);

                                                mipsAsignation = "sw "+temp+", "+ladoIzqId.toString();                            
                                                mipsMain.append("\n   "+mipsAsignation);
                                                RESULT = "int ::"+temp; 

                                                // +++ Tabla de símbolos ++++ 
                                                listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                                                RESULT = id.toString()+": "+tip.toString();
                                            }
                                        }else{
                                            //Manejo error semántico
                                            manejoError("'" + tip +" # "+ id + ";' " + "El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+currentHash, "semántico");
                                            RESULT = "error_semantico";
                                        }

                                    }
                                }
                            }
                            else{
                                //Manejo error semántico
                                manejoError("'" + tip +" # "+ id + " = " + partes_op[0] + ";' " + "El tipo de dato de '"+partes_op[0]+"' es incompatible", "semántico");
                                RESULT = "error_semantico";
                            }
                        }
                    }
                :} ;

CREAVARINT          ::= TIPOINT:tip SEPARADOR IDENTIFICADOR:id ENDLINE
                {:   // ++++ Análisis semántico ++++
                    if(fatherCurrentHash != null && buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), id.toString(), "id") == null){
                        if(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null ) {
                            // ++++ Código 3D ++++
                            codIn3D.append("\ndataInt"+" "+id.toString());
                            mipsData.append("   " + id.toString()+": ."+"word 0"+"\n");

                            // +++ Tabla de símbolos ++++ 
                            listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                            RESULT = id.toString()+": "+tip.toString();
                        }
                        else{
                            //Manejo error semántico
                            manejoError("'" + tip +" # "+ id + ";' " + "El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+currentHash, "semántico");
                            RESULT = "error_semantico";
                        }
                    }
                    else if(fatherCurrentHash == null && buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null){
                            // ++++ Código 3D ++++
                            codIn3D.append("\ndataInt"+" "+id.toString());
                            mipsData.append("   " + id.toString()+": ."+"word 0"+"\n");

                            // +++ Tabla de símbolos ++++ 
                            listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                            RESULT = id.toString()+": "+tip.toString();
                    }
                    else{
                        //Manejo error semántico
                        manejoError("El ID: '"+id+"' ya ha sido utilizado en otra creación de variable dentro de "+fatherCurrentHash, "semántico");
                        RESULT = "error_semantico";
                    }
                :}; 

CREAASIGVARINT      ::= TIPOINT:tip SEPARADOR IDENTIFICADOR:id SIGNOIGUAL OPERACIONARIT:op ENDLINE
                 {:   // ++++ Análisis semántico ++++
                    String ladoIzqTipo = tip.toString();
                    String ladoIzqId = id.toString(); 

                    if ((op.equals("error_semantico"))){
                        RESULT = "error_semantico";
                    }else{
                        String[] partes_op = op.toString().split(": ");

                        if((ladoIzqTipo.equals(partes_op[1].toString())) || (partes_op[1].toString().equals("var"))){
                            if(!(ladoIzqTipo.equals(partes_op[1].toString())) && buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), partes_op[0].toString(), "id") == null){
                                //Manejo error semántico
                                manejoError("'" + tip +" # "+ id + " = " + partes_op[0] + ";' " + "El ID: '"+ partes_op[0] +"' no ha sido creado anteriormente", "semántico");
                                RESULT = "error_semantico";
                            }else{
                                if (!(ladoIzqTipo.equals(partes_op[1])) && !(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), partes_op[0], "id").equals("int"))){
                                    //Manejo error semántico
                                    manejoError("'" + tip +" # "+ id + " = " + partes_op[0] + ";' " + "La variable: '"+ partes_op[0] +"' no es de tipo int", "semántico");
                                    RESULT = "error_semantico";
                                }else{
                                    if(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null ) {
                                        String temp = "t"+(currentTemp++); 
                                        if (partes_op[0].charAt(0)=='('){
                                            listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                                            codIn3D.append("\ndataInt "+ladoIzqId);
                                            ejecutaOpeArit(partes_op[0]);
                                            mipsMain.append("\n   sw $t0, "+ id);

                                            codIn3D.append("\n"+ ladoIzqId +" = t1");
                                            mipsData.append("   " + ladoIzqId+": ."+"word 0"+"\n");

                                        }else{
                                            // ++++ Código 3D ++++
                                            //String temp = "t"+(currentTemp++); 
                                            if (currentTemp == 10){
                                                currentTemp = 0;
                                            }
                                            codIn3D.append("\ndataInt "+ladoIzqId);
                                            codIn3D.append("\n"+ temp +" = "+partes_op[0].toString());                                        
                                            codIn3D.append("\n"+ ladoIzqId +" = "+temp);
                                            mipsData.append("   " + ladoIzqId+": ."+"word 0"+"\n");

                                            String mipsAsignation = "";
                                            if(partes_op[1].equals("var")){
                                                mipsAsignation = "lw $"+temp+", "+ partes_op[0];
                                            }else{
                                                mipsAsignation = "li $"+temp+", "+ partes_op[0];
                                            }
                                            mipsMain.append("\n   "+mipsAsignation);

                                            mipsAsignation = "sw "+temp+", "+ladoIzqId.toString();                            
                                            mipsMain.append("\n   "+mipsAsignation);
                                            RESULT = "int ::"+temp; 

                                            // +++ Tabla de símbolos ++++ 
                                            listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                                            RESULT = id.toString()+": "+tip.toString();
                                        }
                                    }else{
                                        //Manejo error semántico
                                        manejoError("'" + tip +" # "+ id + ";' " + "El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+currentHash, "semántico");
                                        RESULT = "error_semantico";
                                    }

                                }
                            }
                        }
                        else{
                            //Manejo error semántico
                            manejoError("'" + tip +" # "+ id + " = " + partes_op[0] + ";' " + "El tipo de dato de '"+partes_op[0]+"' es incompatible", "semántico");
                            RESULT = "error_semantico";
                        }
                    }
                :} ;

VARIABLESINT        ::= ASIGNVAR 
                        | CREAVARINT 
                        | CREAASIGVARINT;

CREAVARFLOAT        ::= TIPOFLOAT:tip SEPARADOR IDENTIFICADOR:id ENDLINE
                {:   // ++++ Análisis semántico ++++
                    if(fatherCurrentHash != null && buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), id.toString(), "id") == null){
                        if(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null ) {
                            // ++++ Código 3D ++++
                            codIn3D.append("\ndataFloat"+" "+id.toString());
                            mipsData.append("   " + id.toString()+": ."+"float 0.0"+"\n");

                            // +++ Tabla de símbolos ++++ 
                            listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                            RESULT = id.toString()+": "+tip.toString();
                        }
                        else{
                            //Manejo error semántico
                            manejoError("El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+currentHash, "semántico");
                            RESULT = "error_semantico";
                        }
                    }
                    else if(fatherCurrentHash == null && buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null){
                            // ++++ Código 3D ++++
                            codIn3D.append("\ndataFloat"+" "+id.toString());
                            mipsData.append("   " + id.toString()+": ."+"float 0.0"+"\n");

                            // +++ Tabla de símbolos ++++ 
                            listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                            RESULT = id.toString()+": "+tip.toString();
                    }
                    else{
                        //Manejo error semántico
                        manejoError("El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+fatherCurrentHash, "semántico");
                        RESULT = "error_semantico";
                    }
                :}; 

CREAASIGVARFLOAT    ::= TIPOFLOAT:tip SEPARADOR IDENTIFICADOR:id SIGNOIGUAL OPERACIONARIT:op ENDLINE
                {:   // ++++ Análisis semántico ++++
                    String ladoIzqTipo = tip.toString();
                    String ladoIzqId = id.toString(); 

                    if ((op.equals("error_semantico"))){
                        RESULT = "error_semantico";
                    }else{
                        String[] partes_op = op.toString().split(": ");

                        if((ladoIzqTipo.equals(partes_op[1].toString())) || (partes_op[1].toString().equals("var"))){
                            if(!(ladoIzqTipo.equals(partes_op[1].toString())) && buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), partes_op[0].toString(), "id") == null){
                                //Manejo error semántico
                                manejoError("'" + tip +" # "+ id + " = " + partes_op[0] + ";' " + "El ID: '"+ partes_op[0] +"' no ha sido creado anteriormente", "semántico");
                                RESULT = "error_semantico";
                            }else{
                                if (!(ladoIzqTipo.equals(partes_op[1])) && !(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), partes_op[0], "id").equals("float"))){
                                    //Manejo error semántico
                                    manejoError("'" + tip +" # "+ id + " = " + partes_op[0] + ";' " + "La variable: '"+ partes_op[0] +"' no es de tipo float", "semántico");
                                    RESULT = "error_semantico";
                                }else{
                                    if(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null ) {
                                        String temp = "t"+(currentTemp++); 
                                        if (partes_op[0].charAt(0)=='('){
                                            listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                                            codIn3D.append("\ndataFloat "+ladoIzqId);
                                            ejecutaOpeArit(partes_op[0]);
                                            mipsMain.append("\n   sw $t0, "+ id);

                                            codIn3D.append("\n"+ ladoIzqId +" = t1");
                                            mipsData.append("   " + ladoIzqId+": ."+"float 0.0"+"\n");

                                        }else{
                                            // ++++ Código 3D ++++
                                            if (currentTemp == 10){
                                                currentTemp = 0;
                                            }
                                            codIn3D.append("\ndataFloat "+ladoIzqId);
                                            codIn3D.append("\n"+ temp +" = "+partes_op[0].toString());                                        
                                            codIn3D.append("\n"+ ladoIzqId +" = "+temp);
                                            mipsData.append("   " + ladoIzqId+": ."+"word 0"+"\n");

                                            String mipsAsignation = "";
                                            if(partes_op[1].equals("var")){
                                                mipsAsignation = "lw $"+temp+", "+ partes_op[0];
                                            }else{
                                                mipsAsignation = "li $"+temp+", "+ partes_op[0];
                                            }
                                            mipsMain.append("\n   "+mipsAsignation);

                                            mipsAsignation = "sw "+temp+", "+ladoIzqId.toString();                            
                                            mipsMain.append("\n   "+mipsAsignation);
                                            RESULT = "float ::"+temp; 

                                            // +++ Tabla de símbolos ++++ 
                                            listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                                            RESULT = id.toString()+": "+tip.toString();
                                        }
                                    }else{
                                        //Manejo error semántico
                                        manejoError("'" + tip +" # "+ id + ";' " + "El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+currentHash, "semántico");
                                        RESULT = "error_semantico";
                                    }

                                }
                            }
                        }
                        else{
                            //Manejo error semántico
                            manejoError("'" + tip +" # "+ id + " = " + partes_op[0] + ";' " + "El tipo de dato de '"+partes_op[0]+"' es incompatible", "semántico");
                            RESULT = "error_semantico";
                        }
                    }
                :} ;

VARIABLESFLOAT      ::= CREAVARFLOAT 
                        | CREAASIGVARFLOAT;

VALORESBOOL         ::= LITBOOL:litBool {: RESULT = litBool.toString()+": "+"bool"; :}  
                        | IDENTIFICADOR: id {: RESULT = id+": "+"var"; :}   
                        | SIGABREPARENT OPERACIONLOGICAS:valor SIGCIERRAPARENT{:RESULT = valor ;:}  
                        | OPERACIONBOOL{: System.out.println("Que paso?"); :};

CREAVARBOOL         ::= TIPOBOOL:tip SEPARADOR IDENTIFICADOR:id ENDLINE
                {:   // ++++ Análisis semántico ++++
                    if(fatherCurrentHash != null && buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), id.toString(), "id") == null){
                        if(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null ) {
                            // ++++ Código 3D ++++
                            codIn3D.append("\ndataBool"+" "+id.toString());
                            mipsData.append("   " + id.toString()+": ."+"word 0"+"\n");

                            // +++ Tabla de símbolos ++++ 
                            listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                            RESULT = id.toString()+": "+tip.toString();
                        }
                        else{
                            //Manejo error semántico
                            manejoError("El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+currentHash, "semántico");
                            RESULT = "error_semantico";
                        }
                    }
                    else if(fatherCurrentHash == null && buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null){
                            // ++++ Código 3D ++++
                            codIn3D.append("\ndataBool"+" "+id.toString());
                            mipsData.append("   " + id.toString()+": ."+"word 0"+"\n");

                            // +++ Tabla de símbolos ++++ 
                            listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                            RESULT = id.toString()+": "+tip.toString();
                    }
                    else{
                        //Manejo error semántico
                        manejoError("El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+fatherCurrentHash, "semántico");
                        RESULT = "error_semantico";
                    }
                :};  

CREAASIGVARBOOL     ::= TIPOBOOL:tip SEPARADOR IDENTIFICADOR:id SIGNOIGUAL VALORESBOOL:dato ENDLINE 
                {: // ++++ Análisis semántico ++++
                    String ladoIzqTipo = tip.toString();
                    String ladoIzqId = id.toString();
                    String[] partes_dato = dato.toString().split(": ");
                    
                    if ((ladoIzqTipo.equals(partes_dato[1])) || (partes_dato[1].equals("var"))){
                         if(!(ladoIzqTipo.equals(partes_dato[1])) && buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), partes_dato[0].toString(), "id") == null){
                            //Manejo error semántico
                            manejoError("'" + tip +" # "+ id + " = " + partes_dato[0] + ";' " + "El ID: '"+ partes_dato[0] +"' no ha sido creado anteriormente", "semántico");
                            RESULT = "error_semantico";
                        }else{
                            if (!(ladoIzqTipo.equals(partes_dato[1])) && !(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), partes_dato[0], "id").equals("bool"))){
                                //Manejo error semántico
                                manejoError("'" + tip +" # "+ id + " = " + partes_dato[0] + ";' " + "La variable: '"+ partes_dato[0] +"' no es de tipo bool", "semántico");
                                RESULT = "error_semantico";
                            }else{
                                if(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null ) {
                                    // ++++ Código 3D ++++
                                    String temp = "t"+(currentTemp++); 
                                    if (currentTemp == 10){
                                        currentTemp = 0;
                                    }
                                    codIn3D.append("\ndataBool "+ladoIzqId);
                                    codIn3D.append("\n"+ temp +" = "+partes_dato[0].toString());                                        
                                    codIn3D.append("\n"+ ladoIzqId +" = "+temp);
                                    mipsData.append("   " + ladoIzqId+": ."+"word 0"+"\n");

                                    String mipsAsignation = "";
                                        if(partes_dato[1].equals("var")){
                                            mipsAsignation = "lw $"+temp+", "+ partes_dato[0];
                                        }else{
                                            mipsAsignation = "li $"+temp+", "+ partes_dato[0];
                                        }
                                        mipsMain.append("\n   "+mipsAsignation);

                                    mipsAsignation = "sw "+temp+", "+ladoIzqId.toString();                            
                                    mipsMain.append("\n   "+mipsAsignation);
                                    RESULT = "bool ::"+temp; 

                                    // +++ Tabla de símbolos ++++ 
                                    listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                                    RESULT = id.toString()+": "+tip.toString();
                                }else{
                                    //Manejo error semántico
                                    manejoError("'" + tip +" # "+ id + " = " + partes_dato[0] + ";' " + "El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+currentHash, "semántico");
                                    RESULT = "error_semantico";
                                }
                            }
                        }
                    }else{
                        //Manejo error semántico
                        manejoError("El ID: "+ ladoIzqId.toString() +" no ha sido creado dentro de la función", "semántico");
                        RESULT = "error_semantico";
                    }
                :}
                        | TIPOBOOL:tip SEPARADOR IDENTIFICADOR:id SIGNOIGUAL SIGNEGACION VALORESBOOL:dato ENDLINE
                            {:// ++++ Análisis semántico ++++
                                String ladoIzqTipo = tip.toString();
                                String ladoIzqId = id.toString();
                                String[] partes_dato = dato.toString().split(": ");

                                if ((ladoIzqTipo.equals(partes_dato[1])) || (partes_dato[1].equals("var"))){
                                     if(!(ladoIzqTipo.equals(partes_dato[1])) && buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), partes_dato[0].toString(), "id") == null){
                                        //Manejo error semántico
                                        manejoError("'" + tip +" # "+ id + " = " + partes_dato[0] + ";' " + "El ID: '"+ partes_dato[0] +"' no ha sido creado anteriormente", "semántico");
                                        RESULT = "error_semantico";
                                    }else{
                                        if (!(ladoIzqTipo.equals(partes_dato[1])) && !(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), partes_dato[0], "id").equals("bool"))){
                                            //Manejo error semántico
                                            manejoError("'" + tip +" # "+ id + " = " + partes_dato[0] + ";' " + "La variable: '"+ partes_dato[0] +"' no es de tipo bool", "semántico");
                                            RESULT = "error_semantico";
                                        }else{
                                            if(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null ) {
                                                // ++++ Código 3D ++++
                                                String temp = "t"+(currentTemp++); 
                                                if (currentTemp == 10){
                                                    currentTemp = 0;
                                                }
                                                Boolean datoFinal = false;
                                                if (partes_dato[0].equals(false)){
                                                    datoFinal=true;
                                                }
                                                codIn3D.append("\ndataBool "+ladoIzqId);
                                                codIn3D.append("\n"+ temp +" = "+datoFinal.toString());                                        
                                                codIn3D.append("\n"+ ladoIzqId +" = "+temp);
                                                mipsData.append("   " + ladoIzqId+": ."+"word 0"+"\n");

                                                String mipsAsignation = "li $"+temp+", "+ datoFinal.toString();
                                                mipsMain.append("\n   "+mipsAsignation);

                                                mipsAsignation = "sw "+temp+", "+ladoIzqId.toString();                            
                                                mipsMain.append("\n   "+mipsAsignation);
                                                RESULT = "bool ::"+temp; 

                                                // +++ Tabla de símbolos ++++ 
                                                listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                                                RESULT = id.toString()+": "+tip.toString();
                                            }else{
                                                //Manejo error semántico
                                                manejoError("'" + tip +" # "+ id + " = " + partes_dato[0] + ";' " + "El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+currentHash, "semántico");
                                                RESULT = "error_semantico";
                                            }
                                        }
                                    }
                                }else{
                                    //Manejo error semántico
                                    manejoError("El ID: "+ ladoIzqId.toString() +" no ha sido creado dentro de la función", "semántico");
                                    RESULT = "error_semantico";
                                } 
                            :};

VARIABLESBOOL       ::= CREAVARBOOL 
                        | CREAASIGVARBOOL;

VALORESCHAR         ::= LITCHAR:litChar {: RESULT = litChar.toString()+": "+"char"; :} 
                        | IDENTIFICADOR:id {: RESULT = id+": "+"var"; :};

CREAVARCHAR         ::= TIPOCHAR:tip SEPARADOR IDENTIFICADOR:id ENDLINE
                {:   // ++++ Análisis semántico ++++
                    if(fatherCurrentHash != null && buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), id.toString(), "id") == null){
                        if(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null ) {
                            // ++++ Código 3D ++++
                            codIn3D.append("\ndataChar"+" "+id.toString());
                            mipsData.append("   " + id.toString()+": ."+"byte 0"+"\n");

                            // +++ Tabla de símbolos ++++ 
                            listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                            RESULT = id.toString()+": "+tip.toString();
                        }
                        else{
                            //Manejo error semántico
                            manejoError("El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+currentHash, "semántico");
                            RESULT = "error_semantico";
                        }
                    }
                    else if(fatherCurrentHash == null && buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null){
                            // ++++ Código 3D ++++
                            codIn3D.append("\ndataChar"+" "+id.toString());
                            mipsData.append("   " + id.toString()+": ."+"byte 0"+"\n");

                            // +++ Tabla de símbolos ++++ 
                            listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                            RESULT = id.toString()+": "+tip.toString();
                    }
                    else{
                        //Manejo error semántico
                        manejoError("El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+fatherCurrentHash, "semántico");
                        RESULT = "error_semantico";
                    }
                :};   

CREAASIGVARCHAR     ::= TIPOCHAR:tip SEPARADOR IDENTIFICADOR:id SIGNOIGUAL VALORESCHAR:dato ENDLINE
                  {: // ++++ Análisis semántico ++++
                    String ladoIzqTipo = tip.toString();
                    String ladoIzqId = id.toString();
                    String[] partes_dato = dato.toString().split(": ");
                    
                    if ((ladoIzqTipo.equals(partes_dato[1])) || (partes_dato[1].equals("var"))){
                         if(!(ladoIzqTipo.equals(partes_dato[1])) && buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), partes_dato[0].toString(), "id") == null){
                            //Manejo error semántico
                            manejoError("'" + tip +" # "+ id + " = " + partes_dato[0] + ";' " + "El ID: '"+ partes_dato[0] +"' no ha sido creado anteriormente", "semántico");
                            RESULT = "error_semantico";
                        }else{
                            if (!(ladoIzqTipo.equals(partes_dato[1])) && !(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), partes_dato[0], "id").equals("char"))){
                                //Manejo error semántico
                                manejoError("'" + tip +" # "+ id + " = " + partes_dato[0] + ";' " + "La variable: '"+ partes_dato[0] +"' no es de tipo char", "semántico");
                                RESULT = "error_semantico";
                            }else{
                                if(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null ) {
                                    // ++++ Código 3D ++++
                                    String temp = "t"+(currentTemp++); 
                                    if (currentTemp == 10){
                                        currentTemp = 0;
                                    }
                                    codIn3D.append("\ndataChar "+ladoIzqId);
                                    codIn3D.append("\n"+ temp +" = "+partes_dato[0].toString());                                        
                                    codIn3D.append("\n"+ ladoIzqId +" = "+temp);
                                    mipsData.append("   " + ladoIzqId+": ."+"byte 0"+"\n");

                                    String mipsAsignation = "";
                                        if(partes_dato[1].equals("var")){
                                            mipsAsignation = "lw $"+temp+", "+ partes_dato[0];
                                        }else{
                                            mipsAsignation = "li $"+temp+", "+ partes_dato[0];
                                        }
                                        mipsMain.append("\n   "+mipsAsignation);

                                    mipsAsignation = "sw "+temp+", "+ladoIzqId.toString();                            
                                    mipsMain.append("\n   "+mipsAsignation);
                                    RESULT = "char ::"+temp; 

                                    // +++ Tabla de símbolos ++++ 
                                    listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                                    RESULT = id.toString()+": "+tip.toString();
                                }else{
                                    //Manejo error semántico
                                    manejoError("'" + tip +" # "+ id + " = " + partes_dato[0] + ";' " + "El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+currentHash, "semántico");
                                    RESULT = "error_semantico";
                                }
                            }
                        }
                    }else{
                        //Manejo error semántico
                        manejoError("El ID: "+ ladoIzqId.toString() +" no ha sido creado dentro de la función", "semántico");
                        RESULT = "error_semantico";
                    }
                :};

VARIABLESCHAR       ::= CREAVARCHAR 
                        | CREAASIGVARCHAR;

VALORESSTRING       ::= LITSTRING:litString {: RESULT = litString.toString()+": "+"string"; :}  
                        | IDENTIFICADOR:id {: RESULT = id+": "+"var"; :};

CREAVARSTRING       ::= TIPOSTRING:tip SEPARADOR IDENTIFICADOR:id ENDLINE
                {:   
                    // ++++ Análisis semántico ++++
                    if(fatherCurrentHash != null && buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), id.toString(), "id") == null){
                        if(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null ) {
                            // ++++ Código 3D ++++
                            codIn3D.append("\ndataString"+" "+id.toString());
                            mipsData.append("   " + id.toString()+": ."+"asciiz \"\""+"\n");

                            // +++ Tabla de símbolos ++++ 
                            listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                            RESULT = id.toString()+": "+tip.toString();
                        }
                        else{
                            //Manejo error semántico
                            manejoError("El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+currentHash, "semántico");
                            RESULT = "error_semantico";
                        }
                    }
                    else if(fatherCurrentHash == null && buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null){
                            // ++++ Código 3D ++++
                            codIn3D.append("\ndataString"+" "+id.toString());
                            mipsData.append("   " + id.toString()+": ."+"asciiz \"\""+"\n");

                            // +++ Tabla de símbolos ++++ 
                            listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                            RESULT = id.toString()+": "+tip.toString();
                    }
                    else{
                        //Manejo error semántico
                        manejoError("El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+fatherCurrentHash, "semántico");
                        RESULT = "error_semantico";
                    }
                :}; 

CREAASIGVARSTRING   ::= TIPOSTRING:tip SEPARADOR IDENTIFICADOR:id SIGNOIGUAL VALORESSTRING:dato ENDLINE
                   {: // ++++ Análisis semántico ++++
                    String ladoIzqTipo = tip.toString();
                    String ladoIzqId = id.toString();
                    String[] partes_dato = dato.toString().split(": ");

                    if ((ladoIzqTipo.equals(partes_dato[1])) || (partes_dato[1].equals("var"))){
                         if(!(ladoIzqTipo.equals(partes_dato[1])) && buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), partes_dato[0].toString(), "id") == null){
                            //Manejo error semántico
                            manejoError("'" + tip +" # "+ id + " = " + partes_dato[0] + ";' " + "El ID: '"+ partes_dato[0] +"' no ha sido creado anteriormente", "semántico");
                            RESULT = "error_semantico";
                        }else{
                            if (!(ladoIzqTipo.equals(partes_dato[1])) && !(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), partes_dato[0], "id").equals("string"))){
                                //Manejo error semántico
                                manejoError("'" + tip +" # "+ id + " = " + partes_dato[0] + ";' " + "La variable: '"+ partes_dato[0] +"' no es de tipo String", "semántico");
                                RESULT = "error_semantico";
                            }else{
                                if(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null ) {
                                    // ++++ Código 3D ++++
                                    String temp = "t"+(currentTemp++); 
                                    if (currentTemp == 10){
                                        currentTemp = 0;
                                    }
                                    codIn3D.append("\ndataChar "+ladoIzqId);
                                    codIn3D.append("\n"+ temp +" = "+partes_dato[0].toString());                                        
                                    codIn3D.append("\n"+ ladoIzqId +" = "+temp);
                                    mipsData.append("   " + ladoIzqId+": ."+"asciiz \"\""+"\n");

                                    String mipsAsignation = "";
                                        if(partes_dato[1].equals("var")){
                                            mipsAsignation = "lw $"+temp+", "+ partes_dato[0];
                                        }else{
                                            mipsAsignation = "li $"+temp+", "+ partes_dato[0];
                                        }
                                        mipsMain.append("\n   "+mipsAsignation);

                                    mipsAsignation = "sw "+temp+", "+ladoIzqId.toString();                            
                                    mipsMain.append("\n   "+mipsAsignation);
                                    RESULT = "string ::"+temp; 

                                    // +++ Tabla de símbolos ++++ 
                                    listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                                    RESULT = id.toString()+": "+tip.toString();
                                }else{
                                    //Manejo error semántico
                                    manejoError("'" + tip +" # "+ id + " = " + partes_dato[0] + ";' " + "El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+currentHash, "semántico");
                                    RESULT = "error_semantico";
                                }
                            }
                        }
                    }else{
                        //Manejo error semántico
                        manejoError("El ID: "+ ladoIzqId.toString() +" no ha sido creado dentro de la función", "semántico");
                        RESULT = "error_semantico";
                    }
                :};

VARIABLESSTRING     ::= CREAVARSTRING 
                        | CREAASIGVARSTRING;

VARIABLES           ::= VARIABLESINT 
                        | VARIABLESFLOAT 
                        | VARIABLESBOOL 
                        | VARIABLESCHAR 
                        | VARIABLESSTRING 
                        | OPERACIONUNARIA;


FUNCLEER            ::= RESERVLEER SIGABREPARENT IDENTIFICADOR:id SIGCIERRAPARENT ENDLINE {: 
                        String tipovar = buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), id.toString(), "id");
                        if (tipovar == null){
                            manejoError("'read(" + id.toString() + ");': la variable '" + id.toString() + "' no ha sido creada", "semántico");
                            RESULT = "error_semantico";
                        }else{
                            if((tipovar.equals("int")) || (tipovar.equals("float"))){
                                System.out.println("Leer todo guchi");//cod de 3d para la lectura
                            }else{
                                manejoError("'read(" + id.toString() + ");': el tipo de la variable '" + id.toString() + "' no es valido, es de tipo:'" + tipovar + "' y debe ser de tipo 'int' o 'float'", "semántico");
                                RESULT = "error_semantico";
                            }
                        }
                    :};

FUNCESCRIBIRINT     ::= RESERVESCRIBIR SIGABREPARENT LITINT SIGCIERRAPARENT ENDLINE;
FUNCESCRIBIRFLOAT   ::= RESERVESCRIBIR SIGABREPARENT LITFLOAT SIGCIERRAPARENT ENDLINE;
FUNCESCRIBIRSTRING  ::= RESERVESCRIBIR SIGABREPARENT LITSTRING SIGCIERRAPARENT ENDLINE;
FUNCESCRIBIRID      ::= RESERVESCRIBIR SIGABREPARENT IDENTIFICADOR:id SIGCIERRAPARENT ENDLINE {:
                        String tipovar = buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), id.toString(), "id");
                        if (tipovar == null){
                            manejoError("'read(" + id.toString() + ");': la variable '" + id.toString() + "' no ha sido creada", "semántico");
                            RESULT = "error_semantico";
                        }else{
                            if((tipovar.equals("int")) || (tipovar.equals("float")) || (tipovar.equals("string"))){
                                System.out.println("Escribe todo guchi");//cod de 3d para la escritura
                            }else{
                                manejoError("'read(" + id.toString() + ");': el tipo de la variable '" + id.toString() + "' no es valido, es de tipo:'" + tipovar + "' y debe ser de tipo 'int', 'float' o 'string'", "semántico");
                                RESULT = "error_semantico";
                            }
                        }
                    :};

FUNCESCRIBIR        ::= FUNCESCRIBIRINT 
                        | FUNCESCRIBIRFLOAT 
                        | FUNCESCRIBIRSTRING 
                        | FUNCESCRIBIRID;

OPERADORESBOOL      ::= IGUAL {: RESULT = "==";:}
                        | SIGDIFERENTE{: RESULT = "!=";:};
OPERANDOBOOLEANO    ::= LITBOOL :litbool {: RESULT = litbool.toString()+": "+"bool"; :} 
                        | IDENTIFICADOR: id {: RESULT = id+": "+"var"; :};
 
OPERACIONBOOL       ::= OPERANDOBOOLEANO OPERADORESBOOL OPERANDOBOOLEANO;

OPERADORESRELA      ::= SIGMENOR {: RESULT = "<";:}
                        | SIGMENORIGUAL {: RESULT = "<=";:}
                        | SIGMAYOR {: RESULT = ">";:}
                        | SIGMAYORIGUAL {: RESULT = ">=";:}
                        | OPERADORESBOOL: opBool{: RESULT = opBool;:};

OPERACIONRELAARIT    ::= VALORESARIT:valor {:RESULT = valor ;:};
OPERACIONRELAARIT    ::= VALORESARIT:valor1 OPERADORESRELA:sig VALORESARIT:valor2
                    {:
                        if ((valor1.equals("error_semantico")) || (valor2.equals("error_semantico"))){
                            RESULT = "error_semantico";
                        }else{
                            String[] partes_valor1 = valor1.toString().split(": ");
                            String[] partes_valor2 = valor2.toString().split(": ");
                            boolean errores = false;
                            if(partes_valor1[1].equals("var") || partes_valor2[1].equals("var")){
                                String tipo1 = buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), partes_valor1[0], "id");
                                String tipo2 = buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), partes_valor2[0], "id");
                                if (tipo1==null && tipo2==null){
                                    if(partes_valor2[1].equals("var") && (!partes_valor1[1].equals("var"))){
                                        manejoError("'" + partes_valor1[0] + " " + sig + " " + partes_valor2[0] + "' El la variable '"+ partes_valor2[0] +"' no ha sido creada previamente, dentro de "+currentHash, "semántico");
                                        RESULT = "error_semantico"; 
                                        errores = true;
                                    }else { if(!partes_valor2[1].equals("var") && (partes_valor1[1].equals("var"))){
                                        manejoError("'" + partes_valor1[0] + " " + sig + " " + partes_valor2[0] + "' El la variable '"+ partes_valor1[0] +"' no ha sido creada previamente, dentro de "+currentHash, "semántico");
                                        RESULT = "error_semantico"; 
                                        errores = true;
                                    } else {
                                        manejoError("'" + partes_valor1[0] + " " + sig + " " + partes_valor2[0] + "' Las variables: '"+ partes_valor1[0] +"' y " + partes_valor2[0] + " no han sido creadas previamente, dentro de "+currentHash, "semántico");
                                        RESULT = "error_semantico"; 
                                        errores = true;
                                    }}
                                }else {if (tipo1!=null && tipo2!=null){
                                    if(!tipo1.equals(tipo2)){
                                        manejoError("'" + partes_valor1[0] + " " + sig + " " + partes_valor2[0] + "' El las variables de los operadores no son del mismo tipo, una de tipo '" + partes_valor1[1] + "' y la otra de tipo '" + partes_valor1[1] + "', dentro de "+currentHash, "semántico");errores = true;
                                        RESULT = "error_semantico"; 
                                        errores = true;
                                    }
                                }else{ if (tipo1==null && tipo2!=null){
                                    if(!partes_valor1[1].equals(tipo2)){
                                        manejoError("'" + partes_valor1[0] + " " + sig + " " + partes_valor2[0] + "' El la variable '"+ partes_valor2[0] +"', debe ser de tipo tipo:'" + partes_valor1[1] + "', dentro de "+currentHash, "semántico");
                                        RESULT = "error_semantico"; 
                                        errores = true;
                                    }
                                }else{if (tipo2==null && tipo1!=null){
                                    if(!partes_valor2[1].equals(tipo1)){
                                        manejoError("'" + partes_valor1[0] + " " + sig + " " + partes_valor2[0] + "' El la variable '"+ partes_valor1[0] +"', debe ser de tipo tipo:'" + partes_valor2[1] + "', dentro de "+currentHash, "semántico");
                                        RESULT = "error_semantico"; 
                                        errores = true;
                                    }
                                }}}}
                            }
                            if (!(partes_valor1[1].equals("float")) && (!partes_valor1[1].equals("int")) && (!partes_valor1[1].equals("var"))){
                                //Manejo error semántico
                                errores = true;
                                manejoError("'" + valor1 + " " + sig + " " + valor2 + "' El operador: "+ valor1 +" es de un tipo incorrecto para una operacion aritmetica, dentro de "+currentHash, "semántico");
                                RESULT = "error_semantico";
                            }
                            if (!(partes_valor2[1].equals("float")) && (!partes_valor2[1].equals("int")) && (!partes_valor2[1].equals("var"))){
                                //Manejo error semántico
                                errores = true;
                                manejoError("'" + valor1 + " " + sig + " " + valor2 + "' El operador: "+ valor2 +" es de un tipo incorrecto para una operacion aritmetica, dentro de "+currentHash, "semántico");
                                RESULT = "error_semantico";                               
                            }   
                            if (partes_valor1[1].equals(partes_valor2[1]) || partes_valor1[1].equals("var") || partes_valor2[1].equals("var")){
                                if (!errores){
                                    String tipo = "";
                                    if (partes_valor1[1].equals("var")&& (!partes_valor2[1].equals("var"))){
                                        tipo = partes_valor2[1];
                                    }else{
                                        if (partes_valor2[1].equals("var")&& (!partes_valor1[1].equals("var"))){
                                            tipo = partes_valor1[1];
                                        }else{
                                            if ((!partes_valor2[1].equals("var")) && (!partes_valor1[1].equals("var"))){
                                                tipo = partes_valor1[1];
                                            }else{
                                                tipo = buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), partes_valor1[0], "id");                                                
                                            }
                                        }
                                    }
                                    if (!existeOpeRela){
                                        // codigo Mips para operaciones
                                        mipsFunciones.append("\n\nrelationalOperation:\n  lw $t1, 0($a0)    \n  lw $t2, 0($a1)   \n  lb $t3, 0($a2)    \n  beq $t3, '<', less_than\n  beq $t3, '>', greater_than\n  beq $t3, 'L', less_than_or_equal\n  beq $t3, 'G', greater_than_or_equal\n  beq $t3, 'E', equal\n  beq $t3, 'N', not_equal\nless_than:\n  slt $t0, $t1, $t2  \n  j end_operation\ngreater_than:\n  slt $t0, $t2, $t1   \n  j end_operation\nless_than_or_equal:\n  sle $t0, $t1, $t2   \n  j end_operation\ngreater_than_or_equal:\n  sle $t0, $t2, $t1   \n  j end_operation\nequal:\n  seq $t0, $t1, $t2   \n  j end_operation\nnot_equal:\n  sne $t0, $t1, $t2   \nend_operation:\n  jr $ra");             
                                        existeOpeRela = true;
                                    }
                                    String temp ="";
                                    if (!errores){
                                        temp = "[" + partes_valor1[0] + "'" + sig + "'" + partes_valor2[0] +"]";
                                        RESULT = temp + ": " + tipo; 
                                    }else{
                                        temp = "[" + partes_valor1[0] + "'" + sig + "'" + partes_valor2[0] +"]";
                                        RESULT = temp + ": err";
                                    }
                                }
                            }else{
                                //Manejo error semántico
                                manejoError("'" + valor1 + " " + sig + " " + valor2 + "' Los operadores no son del mismo tipo, dentro de "+currentHash, "semántico");
                                RESULT = "error_semantico";
                            }
                        }
                    :};

OPERANDOSLOGICOS    ::=  LITBOOL:litbool {: RESULT = litbool+": "+"bool"; :} 
                        | SEPARADOR IDENTIFICADOR : id {: RESULT = id+": "+"var"; :}
                        | SIGABREPARENT OPERACIONRELAARIT:op SIGCIERRAPARENT
                {:   // ++++ Análisis semántico ++++
                    String[] partes_op = op.toString().split(": ");
                    ejecutaOpeRela (partes_op[0],".");
                    RESULT = (op);                     
                :};

OPERACIONLOGICAS    ::= OPERANDOSLOGICOS:op 
                {:   
                    if ((op.equals("error_semantico"))){
                        RESULT = "error_semantico";
                    }else{
                        String[] partes_op = op.toString().split(": ");
                        if (partes_op[1].toString().equals("bool") && (!(partes_op[0].charAt(0) == '['))){
                            codIn3D.append("\n t1 = " + partes_op[0]);
                            RESULT = (partes_op[0]);  
                        }

                        else if (partes_op[1].toString().equals("var")){
                            String buscaId = buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), partes_op[0].toString(), "id");
                            if(buscaId != null ) {
                                if (buscaId.equals("bool")){
                                    //codIn3D.append("\n t3 = " + partes_op[0]);
                                    RESULT = (partes_op[0]); 
                                }else{
                                    //Manejo error semántico
                                    manejoError("El ID: "+partes_op[0]+" no es de tipo bool", "semántico");
                                    RESULT = "error_semantico";
                                }
                            }else{
                            
                                //Manejo error semántico
                                manejoError("El ID: "+partes_op[0]+" no ha sido creada anteriormente", "semántico");
                                RESULT = "error_semantico";
                            }
                        }
                        else if (!(partes_op[1].toString().equals("bool") && (partes_op[0].charAt(0) == '['))){
                             RESULT = (partes_op[0]); 
                        }else{
                            //ejecutaOpeRela (partes_op[0],".");
                            RESULT = "error_semantico";    
                        }
                    }
                    System.out.println(RESULT);
                :}; 

OPERACIONLOGICAS    ::= SIGNEGACION OPERANDOSLOGICOS:op
                {:
                    if ((op.equals("error_semantico"))){
System.out.println("ES UNA VAR");
                        RESULT = "error_semantico";
                    }else{
                        String[] partes_op = op.toString().split(": ");
                        boolean datoFinal = true;
                        if (partes_op[1].toString().equals("bool") && (!(partes_op[0].charAt(0) == '['))){
                            if (partes_op[0].equals("true")){
                                datoFinal = false;
                                codIn3D.append("\n t3 = " + datoFinal);
                            }else{
                                codIn3D.append("\n t3 = " + datoFinal);
                            }
                        }

                        if (partes_op[1].toString().equals("var")){

                            String buscaId = buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), partes_op[0].toString(), "id");
                            if(buscaId != null ) {
                                if (buscaId.equals("bool")){
                                    if (partes_op[0].equals("true")){
                                    datoFinal = false;
                                    codIn3D.append("\n t3 = " + datoFinal);
                                }else{
                                    codIn3D.append("\n t3 = " + datoFinal);
                                }
                                }else{
                                    //Manejo error semántico
                                    manejoError("El ID: "+partes_op[0]+" no es de tipo bool", "semántico");
                                    RESULT = "error_semantico";
                                }
                            }else{
                                //Manejo error semántico
                                manejoError("El ID: "+partes_op[0]+" no ha sido creada anteriormente", "semántico");
                                RESULT = "error_semantico";
                            }
                        }else{
                            System.out.print("Es una operacion negativa");
                            //ejecutaOpeRela (partes_op[0],"!");
                            codIn3D.append("\n t1 = !t1");
                            RESULT = (partes_op[0]);    
                        }   
                    }
                :}; 


OPERACIONLOGICAS    ::= OPERACIONLOGICAS:op {:codIn3D.append("\n t10 = t1 ");:} OPERADORESLOGICOS:signo  OPERANDOSLOGICOS:valor 
                {:            
                    if ((op.equals("error_semantico"))){
                        RESULT = "error_semantico";
                    }else{
                        String[] partes_valor = valor.toString().split(": ");
                        if (partes_valor[1].toString().equals("bool")){
                            System.out.print("Es un literal");
                            codIn3D.append("\n t1 = " + partes_valor[0]); 
                        }
                        if (partes_valor[1].toString().equals("var")){// exista, sea bool, t3 meter valor
                            System.out.println("\n Es un variable 111\n");
                            System.out.println(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), partes_valor[0].toString(), "id"));

                            if(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), partes_valor[0].toString(), "id") != null ) {
                                System.out.print(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), partes_valor[0].toString(), "id"));
                            }else{
                                //Manejo error semántico
                                manejoError("El ID: "+partes_valor[0]+" no ha sido creada anteriormente", "semántico");
                                RESULT = "error_semantico";
                                }
                        }
                        codIn3D.append("\n t1 = t10 " + signo + "t1");                        
                        //String[] partes = op.toString().split(": ");
                        //ejecutaOpeRela (partes,".");
                        RESULT = (partes_valor[1]);    
                    }
                :}; 

OPERACIONLOGICAS    ::= SIGABREPARENT OPERACIONLOGICAS:op SIGCIERRAPARENT {:RESULT = op;:}; 

VALORESCONDI        ::= OPERACIONLOGICAS | IDENTIFICADOR : id {: RESULT = id+": "+"var"; :};
CONDICIONES         ::=  SIGABREPARENT VALORESCONDI SIGCIERRAPARENT;
BLOQUECODIGO        ::= VALORESBLOQUECODIGO BLOQUECODIGO
                        | VALORESBLOQUECODIGO 
                        | COMENTARIOS;

ESTRUCTELSE         ::= RESERVELSE SIGABRELLAVES BLOQUECODIGO SIGCIERRALLAVES;
ESTRUCTIF           ::= INICIOIF   CONDIIF  SIGABRELLAVES BLOQUECODIGO SIGCIERRALLAVES ESTRUCTELSE FINIF
                        | INICIOIF CONDIIF SIGABRELLAVES BLOQUECODIGO SIGCIERRALLAVES FINIF;

CONDIIF             ::= CONDICIONES {:bandera=1; condicionWhile();:};

INICIOIF            ::= RESERVIF:reserv SEPARADOR{: 
                            bandera = 1;
                            String tipoTabla = "tipo:condicional:if";
                            ArrayList<String> listaSimbolos = new ArrayList<String>();
                            fatherCurrentHash = currentHash;
                            currentHash = "if_"+(++contador_if)+"_"+ hashTree.get(currentHashPos);
                            listaSimbolos.add(tipoTabla);
                            hashTree.addLast(currentHash);
                            currentHashPos++;
                            listaTablaSimbolos.put(currentHash, listaSimbolos);
                            codIn3D.append("\n_if_" + contador_if + ":");
                            mipsMain.append("\n_if_" + contador_if + ":");
                            
                        :} ;

FINIF               ::= {:    
                            int diferencia = contador_if - contador_fin_if;                            
                            if (diferencia != 0 ){
                                if(contador_if_anidados == 0){contador_if_anidados = diferencia+1;}
                                codIn3D.append("\n_end_if_"+(contador_fin_if + contador_if_anidados-1)+":");
                                mipsMain.append("\n_end_if_"+(contador_fin_if + contador_if_anidados-1)+":");
                                contador_if_anidados -= 1;
                                if(contador_if_anidados == 0){                            
                                    contador_fin_if = contador_if+1;
                                    contador_if_anidados = 0;
                                }
                            }else{
                                codIn3D.append("\n_end_if_"+(contador_if)+":");
                                mipsMain.append("\n_end_if_"+(contador_if)+":");
                                contador_fin_if += 1;  
                            }      
                            //contador_fin_if += 1;  
                        :} ;

PARAMFORRANGEUNO    ::= VALORESARIT:param1
                        {:  
                            String[] partes_valor = param1.toString().split(": ");
                            boolean errores = false;
                            if ((!partes_valor[1].equals("int")) && (!partes_valor[1].equals("var"))){
                                //Manejo error semántico
                                errores = true;
                                manejoError(" El parametro: '"+ partes_valor[0] +"' es de un tipo incorrecto para un parametro del 'forRange', dentro de "+currentHash, "semántico");
                                RESULT = "error_semantico";
                            }else{
                                if (partes_valor[1].equals("var")){
                                    String tipo = buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), partes_valor[0], "id");
                                    if(tipo == null){
                                        //Manejo error semántico
                                        errores = true;
                                        manejoError(" El parametro: '"+ partes_valor[0] +"' es de un variable la cual no ha sido definida previamente, dentro de "+currentHash, "semántico");
                                        RESULT = "error_semantico";
                                    }else {
                                        if(tipo.equals("int")){
                                            RESULT = "1".toString()+": " + "1".toString()+": " + partes_valor[0];
                                        }else{
                                            //Manejo error semántico
                                            errores = true;
                                            manejoError(" El parametro: '"+ partes_valor[0] +"' el tipo de dato de la variable no es correcto, dentro de "+currentHash, "semántico");
                                            RESULT = "error_semantico";
                                        }
                                    }
                                }else{
                                    RESULT = "1".toString()+": " + "1".toString()+": " + partes_valor[0];
                                }
                            }
                        :};
PARAMFORRANGEDOS    ::= VALORESARIT:param1 ENDLINE VALORESARIT:param2
                        {:  
                            String[] partes_valor = param1.toString().split(": ");
                            String[] partes_valor2 = param2.toString().split(": ");
                            boolean errores = false;
                            if ((!partes_valor[1].equals("int")) && (!partes_valor[1].equals("var"))){
                                //Manejo error semántico
                                errores = true;
                                manejoError(" El parametro: '"+ partes_valor[0] +"' es de un tipo incorrecto para un parametro del 'forRange', dentro de "+currentHash, "semántico");
                                RESULT = "error_semantico";
                            }else{
                                if (partes_valor[1].equals("var")){
                                    String tipo = buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), partes_valor[0], "id");
                                    if(tipo == null){
                                        //Manejo error semántico
                                        errores = true;
                                        manejoError(" El parametro: '"+ partes_valor[0] +"' es de un variable la cual no ha sido definida previamente, dentro de "+currentHash, "semántico");
                                        RESULT = "error_semantico";
                                    }else {
                                        if(!tipo.equals("int")){
                                            //Manejo error semántico
                                            errores = true;
                                            manejoError(" El parametro: '"+ partes_valor[0] +"' el tipo de dato de la variable no es correcto, dentro de "+currentHash, "semántico");
                                            RESULT = "error_semantico";
                                        }
                                    }
                                }
                            }
                            //validaciones param2
                            if ((!partes_valor2[1].equals("int")) && (!partes_valor2[1].equals("var"))){
                                //Manejo error semántico
                                errores = true;
                                manejoError(" El parametro: '"+ partes_valor2[0] +"' es de un tipo incorrecto para un parametro del 'forRange', dentro de "+currentHash, "semántico");
                                RESULT = "error_semantico";
                            }else{
                                if (partes_valor2[1].equals("var")){
                                    String tipo = buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), partes_valor2[0], "id");
                                    if(tipo == null){
                                        //Manejo error semántico
                                        errores = true;
                                        manejoError(" El parametro: '"+ partes_valor2[0] +"' es de un variable la cual no ha sido definida previamente, dentro de "+currentHash, "semántico");
                                        RESULT = "error_semantico";
                                    }else {
                                        if(!tipo.equals("int")){
                                            //Manejo error semántico
                                            errores = true;
                                            manejoError(" El parametro: '"+ partes_valor2[0] +"' el tipo de dato de la variable no es correcto, dentro de "+currentHash, "semántico");
                                            RESULT = "error_semantico";
                                        }
                                    }
                                }
                            }
                            if(!errores){ 
                                RESULT = partes_valor[0]+": " + "1".toString()+": " + partes_valor2[0]; 
                            }
                        :};
PARAMFORRANGETRES   ::= VALORESARIT:param1 ENDLINE VALORESARIT:param2 ENDLINE VALORESARIT:param3   
                        {:  
                            String[] partes_valor = param1.toString().split(": ");
                            String[] partes_valor2 = param2.toString().split(": ");
                            String[] partes_valor3 = param3.toString().split(": ");
                            boolean errores = false;
                            if ((!partes_valor[1].equals("int")) && (!partes_valor[1].equals("var"))){
                                //Manejo error semántico
                                errores = true;
                                manejoError(" El parametro: '"+ partes_valor[0] +"' es de un tipo incorrecto para un parametro del 'forRange', dentro de "+currentHash, "semántico");
                                RESULT = "error_semantico";
                            }else{
                                if (partes_valor[1].equals("var")){
                                    String tipo = buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), partes_valor[0], "id");
                                    if(tipo == null){
                                        //Manejo error semántico
                                        errores = true;
                                        manejoError(" El parametro: '"+ partes_valor[0] +"' es de un variable la cual no ha sido definida previamente, dentro de "+currentHash, "semántico");
                                        RESULT = "error_semantico";
                                    }else {
                                        if(!tipo.equals("int")){
                                            //Manejo error semántico
                                            errores = true;
                                            manejoError(" El parametro: '"+ partes_valor[0] +"' el tipo de dato de la variable no es correcto, dentro de "+currentHash, "semántico");
                                            RESULT = "error_semantico";
                                        }
                                    }
                                }
                            }
                            //validaciones param2
                            if ((!partes_valor2[1].equals("int")) && (!partes_valor2[1].equals("var"))){
                                //Manejo error semántico
                                errores = true;
                                manejoError(" El parametro: '"+ partes_valor2[0] +"' es de un tipo incorrecto para un parametro del 'forRange', dentro de "+currentHash, "semántico");
                                RESULT = "error_semantico";
                            }else{
                                if (partes_valor2[1].equals("var")){
                                    String tipo = buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), partes_valor2[0], "id");
                                    if(tipo == null){
                                        //Manejo error semántico
                                        errores = true;
                                        manejoError(" El parametro: '"+ partes_valor2[0] +"' es de un variable la cual no ha sido definida previamente, dentro de "+currentHash, "semántico");
                                        RESULT = "error_semantico";
                                    }else {
                                        if(!tipo.equals("int")){
                                            //Manejo error semántico
                                            errores = true;
                                            manejoError(" El parametro: '"+ partes_valor2[0] +"' el tipo de dato de la variable no es correcto, dentro de "+currentHash, "semántico");
                                            RESULT = "error_semantico";
                                        }
                                    }
                                }
                            }
                            //validaciones param3
                            if ((!partes_valor3[1].equals("int")) && (!partes_valor3[1].equals("var"))){
                                //Manejo error semántico
                                errores = true;
                                manejoError(" El parametro: '"+ partes_valor3[0] +"' es de un tipo incorrecto para un parametro del 'forRange', dentro de "+currentHash, "semántico");
                                RESULT = "error_semantico";
                            }else{
                                if (partes_valor3[1].equals("var")){
                                    String tipo = buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), partes_valor3[0], "id");
                                    if(tipo == null){
                                        //Manejo error semántico
                                        errores = true;
                                        manejoError(" El parametro: '"+ partes_valor3[0] +"' es de un variable la cual no ha sido definida previamente, dentro de "+currentHash, "semántico");
                                        RESULT = "error_semantico";
                                    }else {
                                        if(!tipo.equals("int")){
                                            //Manejo error semántico
                                            errores = true;
                                            manejoError(" El parametro: '"+ partes_valor3[0] +"' el tipo de dato de la variable no es correcto, dentro de "+currentHash, "semántico");
                                            RESULT = "error_semantico";
                                        }
                                    }
                                }
                            }
                            if(!errores){ 
                                RESULT = partes_valor[0]+": " + partes_valor2[0] +": " + partes_valor3[0]; 
                            }
                        :};
PARAMFORRANGE       ::= PARAMFORRANGEUNO:params {: RESULT = params; :}
                        | PARAMFORRANGEDOS:params {: RESULT = params; :}
                        | PARAMFORRANGETRES:params {: RESULT = params; :};

CONDICIONALFOR      ::= PARAMFORRANGE:params {: 
                            if(params.equals("error_semantico")){
                                RESULT = params;
                            }else{
                                String[] partes_param = params.toString().split(": ");
                                codIn3D.append("\ndataInt inicio_for"+ (contador_for) +" = "+partes_param[0].toString());
                                mipsData.append("   inicio_for"+ (contador_for) +": ."+"word 0"+"\n");
                                
                                codIn3D.append("\ndataInt incremento_for"+ (contador_for) +" = "+partes_param[1].toString());
                                mipsData.append("   incremento_for"+ (contador_for) +": ."+"word 0"+"\n"); 
                               
                                codIn3D.append("\ndataInt finaliza_for"+ (contador_for) +" = "+partes_param[2].toString());
                                mipsData.append("   finaliza_for"+ (contador_for) +": ."+"word 0"+"\n");

                                String temp = "t"+(currentTemp++);  
                                String cod3d = "\n\n_condicional_forRange"+contador_for+":\n " + ("t"+(currentTemp++))+ "=inicio_for"+ (contador_for) + "\n" +(" t"+(currentTemp++))+ "= finaliza_for"+ (contador_for) + "\n" +(" t"+(currentTemp++))+ "= "+"t"+(currentTemp-3)+" < t"+(currentTemp-2)+"  \n if "+("t"+(currentTemp))+" goto bloqueCod_forRange"+ (contador_for)+"\n goto _end_forRange"+(contador_for)+"\n";
                                codIn3D.append(cod3d);
                                String codmips = "\n\n_condicional_forRange"+contador_for+":\n "+" lw $t1, inicio_for"+(contador_for)+"\n"+"  lw $t2, finaliza_for"+(contador_for)+ "\n"+"  bge $t1, $t2, _end_forRange" +contador_for+":\n\n_bloqueCodfor" +contador_for+":";
                                mipsMain.append(codmips);
                            }
                        :};

ESTRUCTFORRANGE     ::= INICIOFOR RESERVFORRANGE:resv SIGABREPARENT CONDICIONALFOR SIGCIERRAPARENT SIGABRELLAVES BLOQUECODIGO SIGCIERRALLAVES {:
                                int diferencia = contador_for - contador_fin_for;                            
                                if (diferencia != 0 ){
                                    if(contador_for_anidados == 0){contador_for_anidados = diferencia+1;}
                                        int contForActual = (contador_fin_for + contador_for_anidados-1);
                                        String cod3d = "\n  t0 = inicio_for"+ (contForActual)+ "\n  t1 = incremento_for"+ (contForActual)+ "\n  t2 = t1 + t0"+ "\n  inicio_for"+ (contForActual) + " = t2"+ "\n  goto _condicional_forRange"+(contForActual)+ "\n_end_forRange"+(contForActual)+":";
                                        codIn3D.append(cod3d);

                                        String codmips = "\n  lw $t1, inicio_for"+ (contForActual)+ "\n  lw $t2, incremento_for"+ (contForActual)+ "\n  add $t1,$t1,$t2\n  sw $t1, inicio_for"+ (contForActual)+ "\n  inicio_for"+ (contForActual) + " = t2"+ "\n  j _condicional_forRange"+(contForActual)+ "\n_end_forRange"+(contForActual)+":";
                                        mipsMain.append(codmips);

                                        mipsMain.append("\n_end_if_"+ contForActual +":");

                                        contador_for_anidados -= 1;
                                    if(contador_for_anidados == 0){                            
                                        contador_fin_for = contador_for+1;
                                        contador_for_anidados = 0;
                                    }
                                }else{
                                    String cod3d = "\n  t0 = inicio_for"+ (contador_for)+ "\n  t1 = incremento_for"+ (contador_for)+ "\n  t2 = t1 + t0"+ "\n  inicio_for"+ (contador_for) + " = t2"+ "\n  goto _condicional_forRange"+(contador_for)+ "\n_end_forRange"+(contador_for)+":";
                                    codIn3D.append(cod3d);

                                    String codmips = "\n  lw $t1, inicio_for"+ (contador_for)+ "\n  lw $t2, incremento_for"+ (contador_for)+ "\n  add $t1,$t1,$t2\n  sw $t1, inicio_for"+ (contador_for)+ "\n  inicio_for"+ (contador_for) + " = t2"+ "\n  j _condicional_forRange"+(contador_for)+ "\n_end_forRange"+(contador_for)+":";
                                    mipsMain.append(codmips);
                                    contador_fin_for += 1;  
                                }
                            :};
INICIOFOR           ::= {: 
                            String tipoTabla = "tipo:ciclo:for";
                            ArrayList<String> listaSimbolos = new ArrayList<String>();
                            fatherCurrentHash = currentHash;
                            currentHash = "for_"+(++contador_for)+"_"+fatherCurrentHash;
                            listaSimbolos.add(tipoTabla);
                            hashTree.addLast(currentHash);
                            currentHashPos++;
                            listaTablaSimbolos.put(currentHash, listaSimbolos);
                            codIn3D.append("\n_begin_for_"+(contador_for)+":");
                        :} ;

ESTRUCTWHILE        ::= INIWHILE CONDIWHILE SIGABRELLAVES BLOQUECODIGO SIGCIERRALLAVES 
                        | INIWHILE CONDIWHILE SIGABRELLAVES BLOQUECODIGO SIGCIERRALLAVES ESTRUCTELSE; 

CONDIWHILE          ::= CONDICIONES {:bandera =2; condicionWhile();:};

INIWHILE            ::= RESERVWHILE {:bandera = 2; 
                            String tipoTabla = "tipo:condicional:while";
                            ArrayList<String> listaSimbolos = new ArrayList<String>();
                            fatherCurrentHash = currentHash;
                            currentHash = "while_"+(++contador_while)+"_"+ hashTree.get(currentHashPos);
                            listaSimbolos.add(tipoTabla);
                            hashTree.addLast(currentHash);
                            currentHashPos++;
                            listaTablaSimbolos.put(currentHash, listaSimbolos);
                            codIn3D.append("\n_while_" + contador_while + ":");
                            mipsMain.append("\n_while_" + contador_while + ":");
:};

LITERAL             ::= LITINT:litInt {: RESULT = litInt.toString()+": "+"int"; :}
                        | LITFLOAT:litfloat {: RESULT = litfloat.toString()+": "+"float"; :}
                        | LITCHAR:litchar {: RESULT = litchar+": "+"char"; :}
                        | LITSTRING:litstring {: RESULT = litstring+": "+"string"; :};


CASE                ::= INICASE DOSPUNTOS BLOQUECODIGO {: codIn3D.append("\n_end_case_"+(contador_case) + ":"); mipsMain.append("\n_end_case_"+(contador_case) + ":"); :};
INICASE             ::= RESERVCASE SEPARADOR LITERAL:lit {:  
                            String tip = tipoSwitch;
                            String[] partes_lit = lit.toString().split(": ");
                            if (!(tip.equals(partes_lit[1]))){
                                manejoError("El literal del case: 'case#"+partes_lit[0]+"': No es del mismo tipo de la variable del switch", "semántico");
                                RESULT = "error_semantico";
                            }else{
                                String tipoTabla = "tipo:bloque:case";
                                ArrayList<String> listaSimbolos = new ArrayList<String>();
                                fatherCurrentHash = currentHash;
                                currentHash = "case_"+(contador_case++)+"_"+fatherCurrentHash;
                                listaSimbolos.add(tipoTabla);
                                hashTree.addLast(currentHash);
                                currentHashPos++;
                                listaTablaSimbolos.put(currentHash, listaSimbolos);
                                codIn3D.append("\n\n_begin_case_"+(contador_case)+":");
                                codIn3D.append("\n  t1, "+ partes_lit[0] + "\n" + "  t2, "+varSwitch + "\n" + "  t3 = t1 == t2\n" + "  if ! t3 goto_begin_case_"+(contador_case));

                                mipsMain.append("\n\n_begin_case_"+(contador_case)+":");
                                mipsMain.append("\n  li $t0, "+ partes_lit[0] + "\n" +"  lw $t1, "+varSwitch + "\n" +"  bne $t0, $t1, _end_case_"+(contador_case));
                            }
                        :};
CASES               ::= CASE
                        | CASE CASES;
DEFAULT             ::= INIDEFAULT RESERVDEFAULT DOSPUNTOS BLOQUECODIGO{:  codIn3D.append("\n_end_default_"+(contador_switch) + ":"); mipsMain.append("\n_end_default_"+(contador_switch) + ":"); :};
INIDEFAULT          ::= {: 
                                String tipoTabla = "tipo:bloque:case";
                                ArrayList<String> listaSimbolos = new ArrayList<String>();
                                fatherCurrentHash = currentHash;
                                currentHash = "default_"+(contador_switch)+"_"+fatherCurrentHash;
                                listaSimbolos.add(tipoTabla);
                                hashTree.addLast(currentHash);
                                currentHashPos++;
                                listaTablaSimbolos.put(currentHash, listaSimbolos);
                                codIn3D.append("\n\n_begin_default_"+(contador_switch)+":");

                                mipsMain.append("\n\n_begin_default_"+(contador_switch)+":");
                        :};
ESTRUCTSWITCH       ::= INISWITCH SIGABRELLAVES CASES DEFAULT SIGCIERRALLAVES {:
                            codIn3D.append("\n_end_switch_"+(contador_switch)+":");
                            mipsMain.append("\n_end_switch_"+(contador_switch)+":");
                            contador_fin_if += 1;  
                        :};
INISWITCH           ::= RESERVSWITCH SIGABREPARENT IDENTIFICADOR:id SIGCIERRAPARENT {: 
                            String tip = buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), id.toString(), "id");
                            if (tip == null || id.equals("error_semantico")) {
                                if (!(id.equals("error_semantico"))){
                                    manejoError("El ID: "+id+" no ha sido creado en la funcion de "+currentHash, "semántico");
                                }
                                RESULT = "error_semantico";
                            }else{ if (id.equals("bool")) {
                                manejoError("El ID: "+id+" no puede ser de tipo bool. "+currentHash, "semántico");
                                RESULT = "error_semantico";
                            }else{
                                tipoSwitch = tip;
                                varSwitch = id.toString();
                                String tipoTabla = "tipo:switch:"+"switch_"+(++contador_switch)+": "+tip.toString();
                                ArrayList<String> listaSimbolos = new ArrayList<String>();
                                fatherCurrentHash = currentHash;
                                currentHash = "switch_"+(contador_switch)+"_"+fatherCurrentHash;
                                listaSimbolos.add(tipoTabla);
                                hashTree.addLast(currentHash);
                                currentHashPos++;
                                listaTablaSimbolos.put(currentHash, listaSimbolos);
                                codIn3D.append("\n\n_begin_switch_"+(contador_switch)+":"); 
                                mipsMain.append("\n\n_switch_"+(contador_switch)+":"); 
                            }}
                    :};

TIPOSPARAM          ::= TIPOINT {: RESULT = "int";:} 
                        | TIPOFLOAT {: RESULT = "float";:} 
                        | TIPOBOOL {: RESULT = "bool";:}
                        | TIPOCHAR {: RESULT = "char";:};
PARMFUNC            ::= TIPOSPARAM:tip SEPARADOR IDENTIFICADOR:id ;
                        
PARAMETROFUNCION    ::= PARMFUNC
                        | PARMFUNC COMA PARAMETROFUNCION;
PARAMFUNCIONES      ::= SIGABREPARENT PARAMETROFUNCION SIGCIERRAPARENT
                        | SIGABREPARENT SIGCIERRAPARENT;
FUNCMAIN            ::=  INIFUNMAIN PARAMFUNCIONES SIGABRELLAVES BLOQUECODIGO SIGCIERRALLAVES
                {:  
                    codIn3D.append("\n_main_end:"); 
                    hashTree.removeLast(); 
                :};

INIFUNMAIN          ::=TIPOINT:tip SEPARADOR RESERVMAIN:id
                {:
                    String tipoTabla;
                    if(id.toString().equals("main")){
                     tipoTabla = "tipo:funcion:"+id.toString()+": "+tip.toString();
                    }
                    else{
                     tipoTabla = "tipo:funcion:"+id.toString()+": "+tip.toString();
                    }
                    if(existeFuncion(id.toString()) == null){
                         ArrayList<String> listaSimbolos = new ArrayList<String>();
                         currentHash = id.toString();
                         listaSimbolos.add(tipoTabla);
                         hashTree.addLast(currentHash);
                         listaTablaSimbolos.put(currentHash, listaSimbolos);
                         RESULT = tip.toString()+" "+id.toString();
                         codIn3D.append("\n_"+id.toString()+"_begin:");
                         mipsMain.append("\n"+id.toString()+":");
                    }
                    else{
                         currentHash = id.toString();
                         hashTree.addLast(currentHash);
                         manejoError("Función "+id.toString()+" ya existe", "semántico");
                    }
                :}; 

CREAFUNC            ::= INIFUN PARAMFUNCIONES SIGABRELLAVES BLOQUECODIGO SIGCIERRALLAVES
                {:  
                    codIn3D.append("\n_"+hashTree.getLast()+"_end:"); 
                    hashTree.removeLast(); 
                :};

TIPORETORNO         ::= TIPOINT {: RESULT = "int";:}
                        | TIPOFLOAT {: RESULT = "float";:}
                        | TIPOBOOL {: RESULT = "bool";:};

INIFUN              ::= TIPORETORNO:tip IDENTIFICADOR:id
                {:
                    String tipoTabla = "tipo:funcion:"+id.toString()+": "+tip.toString();
                    if((!(tip.toString().equals("int"))) && (!(tip.toString().equals("float"))) && (!(tip.toString().equals("bool")))){
                        currentHash = id.toString();
                        hashTree.addLast(currentHash);
                        manejoError("El tipo de dato de retorno de la función "+id.toString()+" no es valido", "semántico");
                    }else{
                        if(existeFuncion(id.toString()) == null){
                             ArrayList<String> listaSimbolos = new ArrayList<String>();
                             currentHash = id.toString();
                             listaSimbolos.add(tipoTabla);
                             hashTree.addLast(currentHash);
                             listaTablaSimbolos.put(currentHash, listaSimbolos);
                             RESULT = tip.toString()+" "+id.toString();
                             codIn3D.append("\n_"+id.toString()+"_begin:");
                             mipsMain.append("\n"+id.toString()+":");
                        }
                        else{
                             currentHash = id.toString();
                             hashTree.addLast(currentHash);
                             manejoError("Función "+id.toString()+" ya existe", "semántico");
                        }
                    }
                :}; 


PARAMLLAMARFUNC     ::= LITINT:litInt {: RESULT = litInt.toString()+": "+"int"; :}
                        | LITFLOAT:litfloat {: RESULT = litfloat.toString()+": "+"float"; :}
                        | LITCHAR:litchar {: RESULT = litchar+": "+"char"; :}
                        | LITBOOL:litbool {: RESULT = litbool+": "+"bool"; :}
                        | IDENTIFICADOR:id {: RESULT = id; :}
                        | LLAMARFUNC;

                       

PARAMLLAMAFUNC      ::= PARAMLLAMARFUNC | PARAMLLAMARFUNC COMA PARAMLLAMAFUNC;
LLAMARFUNC          ::= IDENTIFICADOR SIGABREPARENT PARAMLLAMAFUNC SIGCIERRAPARENT ; 
LLAMARFUNC          ::= IDENTIFICADOR SIGABREPARENT SIGCIERRAPARENT ;
SENTLLAMARFUNC      ::= LLAMARFUNC ENDLINE;

SENTENCIA           ::= VARIABLES 
                        | FUNCLEER 
                        | FUNCESCRIBIR ;
ESTRUCTCONTROL      ::= ESTRUCTIF
                        | ESTRUCTSWITCH 
                        | ESTRUCTFORRANGE 
                        | ESTRUCTWHILE;
VALORESBLOQUECODIGO ::= SENTENCIA 
                        | ESTRUCTCONTROL 
                        | RESERVBREAK ENDLINE 
                        | SENTRETURN 
                        | SENTLLAMARFUNC;

GLOBALVAR           ::= CREAVARINT 
                        | CREAASIGVARINT 
                        | CREAVARFLOAT 
                        | CREAASIGVARFLOAT 
                        | CREAVARBOOL 
                        | CREAASIGVARBOOL 
                        | CREAVARCHAR 
                        | CREAASIGVARCHAR 
                        | CREAVARSTRING 
                        | CREAASIGVARSTRING;
VALORPROGRAMA       ::= CREAFUNC 
                        | GLOBALVAR 
                        | COMENTARIOS;
VALORESPROGRAMA     ::= VALORPROGRAMA VALORESPROGRAMA;
PROGRAMA            ::= FUNCMAIN
                        | FUNCMAIN VALORESPROGRAMA
                        | VALORESPROGRAMA FUNCMAIN
                        | VALORESPROGRAMA FUNCMAIN
                        VALORESPROGRAMA;

INICIO              ::= PROGRAMA {: /*imprimirTablaSimbolos(); */imprimirCodigo3D(); /*imprimirCodigoMIPS();*/:};