package sintaxis;

import java_cup.runtime.*;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Collection;

// Aquí va la gramática BNF que hicimos solo que se pone con ::= en vez de la flecha 
// También se declaran los terminales y los no terminales por medio de los símbolos y las producciones

// CODIGO JAVA 

action code {:
    LexerCup lex;
    private Object symbolFactory;
    Symbol token;
    Boolean errores = false;
    HashMap<String, ArrayList<String>> listaTablaSimbolos = new HashMap<String, ArrayList<String>>();
    String currentHash;
    int currentTemp = 0;
    StringBuilder codIn3D = new StringBuilder();
    ArrayList<String> elementosArray = new ArrayList<>();
    ArrayList<String> elementosParametros = new ArrayList<>();
    int contador_for = 0;
    int contador_while = 0;
    int contador_if = 0;
    int contador_fin_if = 1;
    int contador_if_anidados = 0;
    int contador_else = 0;
    String fatherCurrentHash = null;
    LinkedList<String> hashTree = new LinkedList<>();
    int currentHashPos = 0;
    StringBuilder mipsData = new StringBuilder();
    StringBuilder mipsMain = new StringBuilder();
    String stringCreationMips = "";
    int mipsTemp = 0;

    public String existeFuncion(String idBuscado){
        Collection<ArrayList<String>> valores = listaTablaSimbolos.values();
        for (ArrayList<String> tablaSimbolos : valores){
            // Recorre los elementos del ArrayList
            for (String elemento : tablaSimbolos) {
                // Divide el elemento en ID y tipo
                String[] partes = elemento.split(":");
                if (partes[0].equals("tipo") && partes[2].equals(idBuscado)) { // Verifica si el ID coincide con el ID buscado
                    return partes[3].trim(); // Se encontró el ID de la función y se envía el tipo de la función
                }
            }
        }
        return null;   
    }

    /* Constructor del parser, recibe como parámetro el lexer que se va a utilizar 
        Entradas: Lexer lex
        Salidas: Ninguna
        Restricciones: Ninguna
    */

    @SuppressWarnings("deprecation")
    public void parser(LexerCup lex){
        this.lex = lex;
        this.symbolFactory = new DefaultSymbolFactory();
    }
    
    /* Método que se encarga de retornar el valor booleao de errores. Indicando si hubo errores o no
        Entradas: Ninguna
        Salidas: errores
        Restricciones: Ninguna
    */
    public boolean getErrores(){
        return errores;
    }

    /* Método que se encarga de retornar el string buffer del código intermedio 3 direcciones
        Entradas: Ninguna
        Salidas: codIn3D
        Restricciones: Ninguna
    */
    public StringBuilder getCodIn3D(){
        return codIn3D;
    }

    /*
        Método que se encarga de retornar el string buffer del código MIPS
        Entradas: Ninguna
        Salidas: mipsData
        Restricciones: Ninguna
    */
    public StringBuilder getMipsData(){
        return mipsData;
    }

    /*
        Método que se encarga de retornar el string buffer del código MIPS
        Entradas: Ninguna
        Salidas: mipsMain
        Restricciones: Ninguna
    */
    public StringBuilder getMipsMain(){
        return mipsMain;
    }
    /* Método que se encarga de imprimir la tabla de símbolos
        Entradas: Ninguna
        Salidas: Ninguna
        Restricciones: Ninguna
    */
    private void imprimirTablaSimbolos(){
        for(String key: listaTablaSimbolos.keySet()){
            System.out.println("-------------------------");
            System.out.println("Tabla de símbolos: "+key);
            System.out.println("Valores: ");
            for(String item: listaTablaSimbolos.get(key)){
                System.out.println(item);
            }
            System.out.println("");
        }

    }

     /* Método que se encarga de imprimir el string buffer del código intermedio 3 direcciones en la terminal.
        Entradas: Ninguna
        Salidas: Ninguna
        Restricciones: Ninguna
    */
    private void imprimirCodigo3D(){
        System.out.println("++++++++ CODIGO 3D +++++++++");
        System.out.println("");
        System.out.println(codIn3D.toString());
    }


    /* Método que se encarga de imprimir el string buffer del código MIPS en la terminal.
        Entradas: Ninguna
        Salidas: Ninguna
        Restricciones: Ninguna
    */
    private void imprimirCodigoMIPS(){
        System.out.println("++++++++ CODIGO MIPS +++++++++");
        System.out.println("");
        System.out.println(".data\n");
        System.out.println(mipsData.toString());
        System.out.println(".text\n");
        System.out.println(".globl main\n");
        System.out.println(mipsMain.toString());
        System.out.println("   li $v0, 10");
        System.out.println("   syscall");
    }


    /* Método que se encarga de imprimir el string buffer del código MIPS en un archivo .asm.
        Entradas: Ninguna
        Salidas: Ninguna
        Restricciones: Ninguna
    */
    private int addMipsTemp(){
        if (mipsTemp == 9){
            mipsTemp = 0;
        }else{
            mipsTemp++;
        }
        return mipsTemp;
    }

    /*
        Método que se encarga de retornar la tabla de símbolos
        Entradas: Ninguna
        Salidas: tabla de símbolos
        Restricciones: Ninguna
    */
    public HashMap<String, ArrayList<String>> getTablaSimbolos(){
        return listaTablaSimbolos;
    }

    /* Método que se encarga de imprimir en consola el error sintáctico
        Entradas: String error. Error que se va a imprimir
        Salidas: Ninguna. Imprime en consola el error
        Restricciones: Ninguna
    */
    private void manejoError(String error, String tipoError){
        errores = true;
        int linea = lex.getLine();
        int columna = lex.getColumn();
        System.out.println("Error "+tipoError+": "+ error +" (en la linea: " + linea + " y columna: " + columna+")");
        System.out.println("Se continua con el análisis "+tipoError);
    } 

    /* Método que se encarga de buscar en la tabla de símbolos actual un ID y devolver su tipo.
        Entradas: lista: lista de elementos de la tabla de símbolos actual, idBuscado: ID que se requiere buscar y queBusca: si busca el ID de una variable o de una función. 
        Salidas: String o null
        Restricciones: Ninguna
    */
     private String buscarID_o_tipoID(ArrayList<String> tablaSimbolos, String idBuscado, String queBusca) {
        int treeSize = hashTree.indexOf(hashTree.get(currentHashPos));
        for (int i = treeSize; i >= 0; i--) {
            tablaSimbolos = listaTablaSimbolos.get(hashTree.get(i));
            if(queBusca.equals("id")){
                // Recorre los elementos del ArrayList
                for (String elemento : tablaSimbolos) {
                    // Divide el elemento en ID y tipo
                    String[] partes = elemento.split(": ");
                    
                    if (partes[0].equals(idBuscado)) { // Verifica si el ID coincide con el ID buscado
                        return partes[1]; // Se encontró el ID y se envía el tipo del ID
                    }
                    if (partes[0].equals("Parámetro") && partes[1].equals(idBuscado)) { // Verifica si el ID coincide con el ID buscado
                        return partes[2].trim(); // Se encontró el ID y se envía el tipo del ID
                    }	
                }
            }
            else if(queBusca.equals("funcion")){
                // Recorre los elementos del ArrayList
                for (String elemento : tablaSimbolos) {
                    // Divide el elemento en ID y tipo
                    String[] partes = elemento.split(":");
                
                    if (partes[1].equals(idBuscado)) { // Verifica si el ID coincide con el ID buscado
                        return partes[2]; // Se encontró el ID de la función y se envía el tipo de la función
                    }
                }
            }
            else if(queBusca.equals("tamañoArray")){
                // Recorre los elementos del ArrayList
                for (String elemento : tablaSimbolos) {
                    // Divide el elemento en ID y tipo
                    String[] partes = elemento.split(": ");
                
                    if (partes[0].equals(idBuscado)) { // Verifica si el ID coincide con el ID buscado
                        return partes[2]; // Se encontró el ID de la función y se envía el tipo de la función
                    }
                }

            }
        }
        return null;       
    }


    private ArrayList<String> obtenerParametrosFuncion(String funcion){
        Collection<ArrayList<String>> valores = listaTablaSimbolos.values();
        ArrayList<String> parametros = new ArrayList<String>();
        for (ArrayList<String> tablaSimbolos : valores){
            // Recorre los elementos del ArrayList
            for (int i = 0; i < tablaSimbolos.size(); i++) {
                String elemento = tablaSimbolos.get(i);
                // Divide el elemento en ID y tipo
                String[] partes = elemento.split(":");
                if (partes[0].equals("tipo") && partes[2].equals(funcion)) { // Verifica si el ID coincide con el ID buscado
                    for (int j = i+1; j < tablaSimbolos.size(); j++){
                        String linea = tablaSimbolos.get(j); // Se encontró el ID de la función y se envía el tipo de la función
                        if(linea.contains("Parámetro")){
                            parametros.add(linea);
                        }
                    }
                    if (parametros.size() != 0){
                        return parametros;
                    }
                }
            }
        }
        return null;   
    }
    /*  Método que se encarga de verificar si todos los elementos de una lista tienen el mismo tipo de dato.
        Entradas: lista: lista de elementos en donde cada elemento contiene un string tipo: "elemento: tipo de dato". 
        Salidas: boolean, true o false.
        Restricciones: La lista NO puede estar vacía.
    */

    private String verificarTipo_elementosArray(ArrayList<String> lista, String tipoArray){

        for (int i = 0; i < lista.size(); i++) {
            String elemento = lista.get(i);
            String[] partesElemento = elemento.split(": ");
            String tipoDatoElemento = partesElemento[1].trim();

            if (!tipoDatoElemento.equals("error_semantico")){
                if (!tipoDatoElemento.equals(tipoArray)) {
                    return partesElemento[0]; // Los tipos de datos NO son iguales
                }
            }
            else{
                return "error_semantico";
            }  
        }

        return null; // Todos los elementos tienen el mismo tipo de dato
    }
    
:}

parser code {:
:}



//------------------------------------------------------------------------------------------------
terminal        ENDLINE,SEPARADOR,DOSPUNTOS,COMA,SIGNOIGUAL,SIGRESTA,SIGSUMA,SIGMULTI,SIGDIV,SIGMOD,SIGPOT,
                SIGCONJUNCION,SIGDISYUNCION,SIGNEGACION,SIGAUMEN,SIGDIMINU,SIGMENOR,SIGMENORIGUAL,SIGMAYOR,SIGMAYORIGUAL,IGUAL,SIGDIFERENTE,SIGABREPARENT,
                SIGCIERRAPARENT,SIGABRELLAVES,SIGCIERRALLAVES,LITTRUE,LITFALSE,TIPOINT,TIPOFLOAT,TIPOBOOL,TIPOCHAR,TIPOSTRING,RESERVLEER,
                RESERVESCRIBIR,RESERVIF,RESERVELSE,RESERVSWITCH,RESERVWHILE,RESERVFORRANGE,RESERVMAIN,RESERVBREAK,RESERVRETURN,
                RESERVCASE,RESERVDEFAULT,LITINT,LITFLOAT,LITCHAR,LITSTRING,IDENTIFICADOR,COMENTARIOSIMPLE,COMENTARIOMULTIPLE;

non terminal    LITBOOL,OPERADORESARITME,OPERADORESLOGICOS,OPERADORESUNARIOS,OPERADORESRELA,COMENTARIOS,DATOSRETORNO,                
                SENTRETURN,SENTBREAK,OPERAUNARIA,OPERACIONUNARIA,VALORESARIT,OPERACIONARIT,ASIGNVAR,CREAVARINT,CREAASIGVARINT,                
                VARIABLESINT,CREAVARFLOAT,CREAASIGVARFLOAT,VARIABLESFLOAT,VALORESBOOL,       PARAMETROFUNCION,      FINIF, INICIOIF,   
                CREAVARBOOL,CREAASIGVARBOOL,VARIABLESBOOL,VALORESCHAR,CREAVARCHAR,CREAASIGVARCHAR,VARIABLESCHAR,                
                VALORESSTRING,CREAVARSTRING,CREAASIGVARSTRING,VARIABLESSTRING,VARIABLES,FUNCLEER,FUNCESCRIBIRINT,                
                FUNCESCRIBIRFLOAT,FUNCESCRIBIRSTRING,FUNCESCRIBIRID,FUNCESCRIBIR,OPERADORESBOOL,OPERANDOBOOLEANO,OPERACIONBOOL,
                OPERACIONRELAARIT,OPERANDOSLOGICOS,OPERACIONLOGICAS,CONDICIONES,SENTENCIA,ESTRUCTCONTROL,VALORESBLOQUECODIGO,                
                BLOQUECODIGO,ESTRUCTELSE,ESTRUCTIF,PARAMFORRANGEUNO,PARAMFORRANGEDOS,PARAMFORRANGETRES,PARAMFORRANGE,ESTRUCTFORRANGE,                
                ESTRUCTWHILE,LITERAL,CASE,CASES,DEFAULT,ESTRUCTSWITCH,TIPOSPARAM,PARAMFUNCIONES,FUNCMAIN,CREAFUNC,                
                PARMFUNC,PARAMLLAMARFUNC,PARAMLLAMAFUNC,LLAMARFUNC,SENTLLAMARFUNC,GLOBALVAR,VALORPROGRAMA,INIFUN,VALORESPROGRAMA,PROGRAMA,INICIO,VALORESCONDI,INIFUNMAIN,INICIOFOR,TIPORETORNO;

precedence left TIPOINT , TIPOFLOAT , TIPOBOOL , TIPOCHAR ;
precedence left SIGCONJUNCION, SIGDISYUNCION;

start with INICIO;

LITBOOL             ::= LITTRUE {: RESULT = "true"+": "+"bool"; :}
                        | LITFALSE {: RESULT = "false"+": "+"bool"; :};

OPERADORESARITME    ::= SIGRESTA {: RESULT = "-";:} 
                        | SIGSUMA {: RESULT = "+";:} 
                        | SIGMULTI {: RESULT = "*";:} 
                        | SIGDIV {: RESULT = "/";:} 
                        | SIGMOD {: RESULT = "%";:} 
                        | SIGPOT{: RESULT = "^";:};

OPERADORESLOGICOS   ::= SIGCONJUNCION {: RESULT = "&";:} 
                        | SIGDISYUNCION{: RESULT = "|";:};

OPERADORESUNARIOS   ::= SIGAUMEN {: RESULT = "++";:} 
                        | SIGDIMINU {: RESULT = "--";:};

COMENTARIOS         ::= COMENTARIOSIMPLE | COMENTARIOMULTIPLE;

DATOSRETORNO        ::= LITINT:litInt {: RESULT = litInt.toString()+": "+"int"; :}
                        | LITFLOAT:litfloat {: RESULT = litfloat.toString()+": "+"float"; :} 
                        | LITBOOL 
                        | IDENTIFICADOR 
                        | LLAMARFUNC ;
SENTRETURN          ::= RESERVRETURN SEPARADOR DATOSRETORNO ENDLINE;

OPERAUNARIA         ::= IDENTIFICADOR OPERADORESUNARIOS;
OPERAUNARIA         ::= OPERADORESUNARIOS IDENTIFICADOR ;
OPERACIONUNARIA     ::= OPERAUNARIA ENDLINE;

VALORESARIT         ::= LITINT:litInt {: RESULT = litInt.toString()+": "+"int"; :}
                        | LITFLOAT:litfloat {: RESULT = litfloat.toString()+": "+"float"; :}
                        | IDENTIFICADOR : id {: RESULT = id; :} 
                        | LLAMARFUNC 
                        | OPERAUNARIA;                        
OPERACIONARIT       ::= VALORESARIT
                        | VALORESARIT OPERADORESARITME OPERACIONARIT
                        | SIGABREPARENT OPERACIONARIT SIGCIERRAPARENT;

ASIGNVAR            ::= IDENTIFICADOR SIGNOIGUAL OPERACIONARIT ENDLINE;
CREAVARINT          ::= TIPOINT:tip SEPARADOR IDENTIFICADOR:id ENDLINE
                {:   // ++++ Análisis semántico ++++
                    if(fatherCurrentHash != null && buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), id.toString(), "id") == null){
                        if(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null ) {
                            // ++++ Código 3D ++++
                            codIn3D.append("\ndata_"+tip.toString()+" "+id.toString());
                            mipsData.append("   " + id.toString()+": ."+"word 0"+"\n");

                            // +++ Tabla de símbolos ++++ 
                            listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                            RESULT = id.toString()+": "+tip.toString();
                        }
                        else{
                            //Manejo error semántico
                            manejoError("El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+currentHash, "semántico");
                            RESULT = "error_semantico";
                        }
                    }
                    else if(fatherCurrentHash == null && buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null){
                            // ++++ Código 3D ++++
                            codIn3D.append("\ndata_"+tip.toString()+" "+id.toString());
                            mipsData.append("   " + id.toString()+": ."+"word 0"+"\n");

                            // +++ Tabla de símbolos ++++ 
                            listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                            RESULT = id.toString()+": "+tip.toString();
                    }
                    else{
                        //Manejo error semántico
                        manejoError("El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+fatherCurrentHash, "semántico");
                        RESULT = "error_semantico";
                    }
                :}; 

CREAASIGVARINT      ::= TIPOINT SEPARADOR IDENTIFICADOR SIGNOIGUAL OPERACIONARIT ENDLINE;
VARIABLESINT        ::= ASIGNVAR 
                        | CREAVARINT 
                        | CREAASIGVARINT;

CREAVARFLOAT        ::= TIPOFLOAT:tip SEPARADOR IDENTIFICADOR:id ENDLINE
                {:   // ++++ Análisis semántico ++++
                    if(fatherCurrentHash != null && buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), id.toString(), "id") == null){
                        if(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null ) {
                            // ++++ Código 3D ++++
                            codIn3D.append("\ndata_"+tip.toString()+" "+id.toString());
                            mipsData.append("   " + id.toString()+": ."+"float 0.0"+"\n");

                            // +++ Tabla de símbolos ++++ 
                            listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                            RESULT = id.toString()+": "+tip.toString();
                        }
                        else{
                            //Manejo error semántico
                            manejoError("El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+currentHash, "semántico");
                            RESULT = "error_semantico";
                        }
                    }
                    else if(fatherCurrentHash == null && buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null){
                            // ++++ Código 3D ++++
                            codIn3D.append("\ndata_"+tip.toString()+" "+id.toString());
                            mipsData.append("   " + id.toString()+": ."+"float 0.0"+"\n");

                            // +++ Tabla de símbolos ++++ 
                            listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                            RESULT = id.toString()+": "+tip.toString();
                    }
                    else{
                        //Manejo error semántico
                        manejoError("El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+fatherCurrentHash, "semántico");
                        RESULT = "error_semantico";
                    }
                :}; 

CREAASIGVARFLOAT    ::= TIPOFLOAT SEPARADOR IDENTIFICADOR SIGNOIGUAL OPERACIONARIT ENDLINE;
VARIABLESFLOAT      ::= CREAVARFLOAT 
                        | CREAASIGVARFLOAT;

VALORESBOOL         ::= LITBOOL  
                        | IDENTIFICADOR  
                        | SIGABREPARENT OPERACIONRELAARIT SIGCIERRAPARENT  
                        | OPERACIONBOOL{: System.out.println("Que paso?"); :};
CREAVARBOOL         ::= TIPOBOOL:tip SEPARADOR IDENTIFICADOR:id ENDLINE
                {:   // ++++ Análisis semántico ++++
                    if(fatherCurrentHash != null && buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), id.toString(), "id") == null){
                        if(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null ) {
                            // ++++ Código 3D ++++
                            codIn3D.append("\ndata_"+tip.toString()+" "+id.toString());
                            mipsData.append("   " + id.toString()+": ."+"word 0"+"\n");

                            // +++ Tabla de símbolos ++++ 
                            listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                            RESULT = id.toString()+": "+tip.toString();
                        }
                        else{
                            //Manejo error semántico
                            manejoError("El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+currentHash, "semántico");
                            RESULT = "error_semantico";
                        }
                    }
                    else if(fatherCurrentHash == null && buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null){
                            // ++++ Código 3D ++++
                            codIn3D.append("\ndata_"+tip.toString()+" "+id.toString());
                            mipsData.append("   " + id.toString()+": ."+"word 0"+"\n");

                            // +++ Tabla de símbolos ++++ 
                            listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                            RESULT = id.toString()+": "+tip.toString();
                    }
                    else{
                        //Manejo error semántico
                        manejoError("El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+fatherCurrentHash, "semántico");
                        RESULT = "error_semantico";
                    }
                :};  

CREAASIGVARBOOL     ::= TIPOBOOL SEPARADOR IDENTIFICADOR SIGNOIGUAL VALORESBOOL ENDLINE 
                        | TIPOBOOL SEPARADOR IDENTIFICADOR SIGNOIGUAL SIGNEGACION VALORESBOOL ENDLINE;
VARIABLESBOOL       ::= CREAVARBOOL 
                        | CREAASIGVARBOOL;

VALORESCHAR         ::= LITCHAR 
                        | IDENTIFICADOR;
CREAVARCHAR         ::= TIPOCHAR:tip SEPARADOR IDENTIFICADOR:id ENDLINE
                {:   // ++++ Análisis semántico ++++
                    if(fatherCurrentHash != null && buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), id.toString(), "id") == null){
                        if(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null ) {
                            // ++++ Código 3D ++++
                            codIn3D.append("\ndata_"+tip.toString()+" "+id.toString());
                            mipsData.append("   " + id.toString()+": ."+"byte 0"+"\n");

                            // +++ Tabla de símbolos ++++ 
                            listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                            RESULT = id.toString()+": "+tip.toString();
                        }
                        else{
                            //Manejo error semántico
                            manejoError("El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+currentHash, "semántico");
                            RESULT = "error_semantico";
                        }
                    }
                    else if(fatherCurrentHash == null && buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null){
                            // ++++ Código 3D ++++
                            codIn3D.append("\ndata_"+tip.toString()+" "+id.toString());
                            mipsData.append("   " + id.toString()+": ."+"byte 0"+"\n");

                            // +++ Tabla de símbolos ++++ 
                            listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                            RESULT = id.toString()+": "+tip.toString();
                    }
                    else{
                        //Manejo error semántico
                        manejoError("El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+fatherCurrentHash, "semántico");
                        RESULT = "error_semantico";
                    }
                :};   

CREAASIGVARCHAR     ::= TIPOCHAR SEPARADOR IDENTIFICADOR SIGNOIGUAL VALORESCHAR ENDLINE;
VARIABLESCHAR       ::= CREAVARCHAR 
                        | CREAASIGVARCHAR;

VALORESSTRING       ::= LITSTRING 
                        | IDENTIFICADOR;
CREAVARSTRING       ::= TIPOSTRING:tip SEPARADOR IDENTIFICADOR:id ENDLINE
                {:   
                    // ++++ Análisis semántico ++++
                    if(fatherCurrentHash != null && buscarID_o_tipoID(listaTablaSimbolos.get(fatherCurrentHash), id.toString(), "id") == null){
                        if(buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null ) {
                            // ++++ Código 3D ++++
                            codIn3D.append("\ndata_"+tip.toString()+" "+id.toString());
                            mipsData.append("   " + id.toString()+": ."+"asciiz \"\""+"\n");

                            // +++ Tabla de símbolos ++++ 
                            listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                            RESULT = id.toString()+": "+tip.toString();
                        }
                        else{
                            //Manejo error semántico
                            manejoError("El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+currentHash, "semántico");
                            RESULT = "error_semantico";
                        }
                    }
                    else if(fatherCurrentHash == null && buscarID_o_tipoID(listaTablaSimbolos.get(currentHash), id.toString(), "id") == null){
                            // ++++ Código 3D ++++
                            codIn3D.append("\ndata_"+tip.toString()+" "+id.toString());
                            mipsData.append("   " + id.toString()+": ."+"asciiz \"\""+"\n");

                            // +++ Tabla de símbolos ++++ 
                            listaTablaSimbolos.get(currentHash).add(id.toString()+": "+tip.toString());
                            RESULT = id.toString()+": "+tip.toString();
                    }
                    else{
                        //Manejo error semántico
                        manejoError("El ID: "+id+" ya ha sido utilizado en otra creación de variable dentro de "+fatherCurrentHash, "semántico");
                        RESULT = "error_semantico";
                    }
                :}; 

CREAASIGVARSTRING   ::= TIPOSTRING SEPARADOR IDENTIFICADOR SIGNOIGUAL VALORESSTRING ENDLINE;
VARIABLESSTRING     ::= CREAVARSTRING 
                        | CREAASIGVARSTRING;

VARIABLES           ::= VARIABLESINT 
                        | VARIABLESFLOAT 
                        | VARIABLESBOOL 
                        | VARIABLESCHAR 
                        | VARIABLESSTRING 
                        | OPERACIONUNARIA;

FUNCLEER            ::= RESERVLEER SIGABREPARENT IDENTIFICADOR SIGCIERRAPARENT ENDLINE;

FUNCESCRIBIRINT     ::= RESERVESCRIBIR SIGABREPARENT LITINT SIGCIERRAPARENT ENDLINE;
FUNCESCRIBIRFLOAT   ::= RESERVESCRIBIR SIGABREPARENT LITFLOAT SIGCIERRAPARENT ENDLINE;
FUNCESCRIBIRSTRING  ::= RESERVESCRIBIR SIGABREPARENT LITSTRING SIGCIERRAPARENT ENDLINE;
FUNCESCRIBIRID      ::= RESERVESCRIBIR SIGABREPARENT IDENTIFICADOR SIGCIERRAPARENT ENDLINE;
FUNCESCRIBIR        ::= FUNCESCRIBIRINT 
                        | FUNCESCRIBIRFLOAT 
                        | FUNCESCRIBIRSTRING 
                        | FUNCESCRIBIRID;

OPERADORESBOOL      ::= IGUAL 
                        | SIGDIFERENTE;
OPERANDOBOOLEANO    ::= LITBOOL 
                        | IDENTIFICADOR;
OPERACIONBOOL       ::= OPERANDOBOOLEANO OPERADORESBOOL OPERANDOBOOLEANO;


OPERADORESRELA      ::= SIGMENOR 
                        | SIGMENORIGUAL 
                        | SIGMAYOR 
                        | SIGMAYORIGUAL 
                        | OPERADORESBOOL ;


OPERACIONRELAARIT    ::= VALORESARIT;
OPERACIONRELAARIT    ::= VALORESARIT OPERADORESRELA VALORESARIT;

OPERANDOSLOGICOS    ::=  LITBOOL:lit | SEPARADOR IDENTIFICADOR
                        | SIGABREPARENT OPERACIONRELAARIT SIGCIERRAPARENT;
OPERACIONLOGICAS    ::= OPERANDOSLOGICOS;
OPERACIONLOGICAS    ::= SIGNEGACION OPERANDOSLOGICOS;
OPERACIONLOGICAS    ::= OPERACIONLOGICAS OPERADORESLOGICOS OPERANDOSLOGICOS;
OPERACIONLOGICAS    ::= SIGABREPARENT OPERACIONLOGICAS SIGCIERRAPARENT;


VALORESCONDI        ::= OPERACIONLOGICAS | IDENTIFICADOR;
CONDICIONES         ::=  SIGABREPARENT VALORESCONDI SIGCIERRAPARENT;

BLOQUECODIGO        ::= VALORESBLOQUECODIGO BLOQUECODIGO
                        | VALORESBLOQUECODIGO 
                        | COMENTARIOS;

ESTRUCTELSE         ::= RESERVELSE SIGABRELLAVES BLOQUECODIGO SIGCIERRALLAVES;
ESTRUCTIF           ::= INICIOIF CONDICIONES SIGABRELLAVES BLOQUECODIGO SIGCIERRALLAVES ESTRUCTELSE FINIF
                        | INICIOIF CONDICIONES SIGABRELLAVES BLOQUECODIGO SIGCIERRALLAVES FINIF;
INICIOIF            ::= RESERVIF:reserv SEPARADOR {: 
                            String tipoTabla = "tipo:condicional:if";
                            ArrayList<String> listaSimbolos = new ArrayList<String>();
                            fatherCurrentHash = currentHash;
                            currentHash = "if_"+(++contador_if)+"_"+ hashTree.get(currentHashPos);
                            listaSimbolos.add(tipoTabla);
                            hashTree.addLast(currentHash);
                            currentHashPos++;
                            listaTablaSimbolos.put(currentHash, listaSimbolos);
                            codIn3D.append("\n_if_" + contador_if + ":");
                            mipsMain.append("\n_if_" + contador_if + ":");
                        :} ;

FINIF               ::= {:    
                            int diferencia = contador_if - contador_fin_if;                            
                            if (diferencia != 0 ){
                                if(contador_if_anidados == 0){contador_if_anidados = diferencia+1;}
                                codIn3D.append("\n_end_if_"+(contador_fin_if + contador_if_anidados-1)+":");
                                mipsMain.append("\n_end_if_"+(contador_fin_if + contador_if_anidados-1)+":");
                                contador_if_anidados -= 1;
                                if(contador_if_anidados == 0){                            
                                    contador_fin_if = contador_if+1;
                                    contador_if_anidados = 0;
                                }
                            }else{
                                codIn3D.append("\n_end_if_"+(contador_if)+":");
                                mipsMain.append("\n_end_if_"+(contador_if)+":");
                                contador_fin_if += 1;  
                            }      
                            //contador_fin_if += 1;  
                        :} ;

PARAMFORRANGEUNO    ::= LITINT:litInt {: RESULT = litInt.toString()+": "+"int"; :};
PARAMFORRANGEDOS    ::= LITINT:parm1 ENDLINE LITINT:parm2 {: RESULT = parm1.toString()+": "+"paramInicia" + parm2.toString()+": "+"paramFinaliza"; :};
PARAMFORRANGETRES   ::= LITINT:parm1 ENDLINE LITINT:parm2 ENDLINE LITINT:parm3 {: RESULT = parm1.toString()+": "+"paramInicia" + parm2.toString()+": "+"paramIncremento" + parm3.toString()+": "+"paramFinaliza"; :};
PARAMFORRANGE       ::= PARAMFORRANGEUNO 
                        | PARAMFORRANGEDOS 
                        | PARAMFORRANGETRES;
ESTRUCTFORRANGE     ::= INICIOFOR RESERVFORRANGE SIGABREPARENT PARAMFORRANGE SIGCIERRAPARENT SIGABRELLAVES BLOQUECODIGO SIGCIERRALLAVES;
INICIOFOR           ::= {: 
                            String tipoTabla = "tipo:ciclo:for";
                            ArrayList<String> listaSimbolos = new ArrayList<String>();
                            fatherCurrentHash = currentHash;
                            currentHash = "for_"+(++contador_for)+"_"+fatherCurrentHash;
                            listaSimbolos.add(tipoTabla);
                            hashTree.addLast(currentHash);
                            currentHashPos++;
                            listaTablaSimbolos.put(currentHash, listaSimbolos);
                            codIn3D.append("\n_begin_for_"+(contador_for)+":");
                        :} ;


ESTRUCTWHILE        ::= RESERVWHILE CONDICIONES SIGABRELLAVES BLOQUECODIGO SIGCIERRALLAVES 
                        | RESERVWHILE CONDICIONES SIGABRELLAVES BLOQUECODIGO SIGCIERRALLAVES ESTRUCTELSE;

LITERAL             ::= LITINT:litInt {: RESULT = litInt.toString()+": "+"int"; :}
                        | LITFLOAT:litfloat {: RESULT = litfloat.toString()+": "+"float"; :}
                        | LITCHAR:litchar {: RESULT = litchar+": "+"char"; :}
                        | LITSTRING:litstring {: RESULT = litstring+": "+"string"; :};

CASE                ::= RESERVCASE SEPARADOR LITERAL DOSPUNTOS BLOQUECODIGO SENTBREAK;
CASES               ::= CASE | CASE CASES;
DEFAULT             ::= RESERVDEFAULT DOSPUNTOS BLOQUECODIGO SENTBREAK;
ESTRUCTSWITCH       ::= RESERVSWITCH SIGABREPARENT IDENTIFICADOR SIGCIERRAPARENT SIGABRELLAVES CASES DEFAULT SIGCIERRALLAVES;

TIPOSPARAM          ::= TIPOINT {: RESULT = "int";:} 
                        | TIPOFLOAT {: RESULT = "float";:} 
                        | TIPOBOOL {: RESULT = "bool";:}
                        | TIPOCHAR {: RESULT = "char";:};
PARMFUNC            ::= TIPOSPARAM:tip SEPARADOR IDENTIFICADOR:id ;
                        
PARAMETROFUNCION    ::= PARMFUNC
                        | PARMFUNC COMA PARAMETROFUNCION;
PARAMFUNCIONES      ::= SIGABREPARENT PARAMETROFUNCION SIGCIERRAPARENT
                        | SIGABREPARENT SIGCIERRAPARENT;
FUNCMAIN            ::=  INIFUNMAIN PARAMFUNCIONES SIGABRELLAVES BLOQUECODIGO SIGCIERRALLAVES
                {:  
                    codIn3D.append("\n_main_end:"); 
                    hashTree.removeLast(); 
                :};

INIFUNMAIN          ::=TIPOINT:tip SEPARADOR RESERVMAIN:id
                {:
                    String tipoTabla;
                    if(id.toString().equals("main")){
                     tipoTabla = "tipo:funcion:"+id.toString()+": "+tip.toString();
                    }
                    else{
                     tipoTabla = "tipo:funcion:"+id.toString()+": "+tip.toString();
                    }
                    if(existeFuncion(id.toString()) == null){
                         ArrayList<String> listaSimbolos = new ArrayList<String>();
                         currentHash = id.toString();
                         listaSimbolos.add(tipoTabla);
                         hashTree.addLast(currentHash);
                         listaTablaSimbolos.put(currentHash, listaSimbolos);
                         RESULT = tip.toString()+" "+id.toString();
                         codIn3D.append("\n_"+id.toString()+"_begin:");
                         mipsMain.append("\n"+id.toString()+":");
                    }
                    else{
                         currentHash = id.toString();
                         hashTree.addLast(currentHash);
                         manejoError("Función "+id.toString()+" ya existe", "semántico");
                    }
                :}; 

CREAFUNC            ::= INIFUN PARAMFUNCIONES SIGABRELLAVES BLOQUECODIGO SIGCIERRALLAVES
                {:  
                    codIn3D.append("\n_"+hashTree.getLast()+"_end:"); 
                    hashTree.removeLast(); 
                :};

TIPORETORNO         ::= TIPOINT {: RESULT = "int";:}
                        | TIPOFLOAT {: RESULT = "float";:}
                        | TIPOBOOL {: RESULT = "boolean";:};

INIFUN              ::= TIPORETORNO:tip IDENTIFICADOR:id
                {:
                    String tipoTabla = "tipo:funcion:"+id.toString()+": "+tip.toString();
                    if((!(tip.toString().equals("int"))) && (!(tip.toString().equals("float"))) && (!(tip.toString().equals("bool")))){
                        currentHash = id.toString();
                        hashTree.addLast(currentHash);
                        manejoError("El tipo de dato de retorno de la función "+id.toString()+" no es valido", "semántico");
                    }else{
                        if(existeFuncion(id.toString()) == null){
                             ArrayList<String> listaSimbolos = new ArrayList<String>();
                             currentHash = id.toString();
                             listaSimbolos.add(tipoTabla);
                             hashTree.addLast(currentHash);
                             listaTablaSimbolos.put(currentHash, listaSimbolos);
                             RESULT = tip.toString()+" "+id.toString();
                             codIn3D.append("\n_"+id.toString()+"_begin:");
                             mipsMain.append("\n"+id.toString()+":");
                        }
                        else{
                             currentHash = id.toString();
                             hashTree.addLast(currentHash);
                             manejoError("Función "+id.toString()+" ya existe", "semántico");
                        }
                    }
                :}; 


PARAMLLAMARFUNC     ::= LITINT:litInt {: RESULT = litInt.toString()+": "+"int"; :}
                        | LITFLOAT:litfloat {: RESULT = litfloat.toString()+": "+"float"; :}
                        | LITCHAR:litchar {: RESULT = litchar+": "+"char"; :}
                        | LITBOOL:litbool {: RESULT = litbool+": "+"bool"; :}
                        | IDENTIFICADOR:id {: RESULT = id; :}
                        | LLAMARFUNC;

                       

PARAMLLAMAFUNC      ::= PARAMLLAMARFUNC | PARAMLLAMARFUNC COMA PARAMLLAMAFUNC;
LLAMARFUNC          ::= IDENTIFICADOR SIGABREPARENT PARAMLLAMAFUNC SIGCIERRAPARENT ; 
LLAMARFUNC          ::= IDENTIFICADOR SIGABREPARENT SIGCIERRAPARENT ;
SENTLLAMARFUNC      ::= LLAMARFUNC ENDLINE;

SENTENCIA           ::= VARIABLES 
                        | FUNCLEER 
                        | FUNCESCRIBIR ;
ESTRUCTCONTROL      ::= ESTRUCTIF
                        | ESTRUCTSWITCH 
                        | ESTRUCTFORRANGE 
                        | ESTRUCTWHILE;
VALORESBLOQUECODIGO ::= SENTENCIA 
                        | ESTRUCTCONTROL 
                        | RESERVBREAK ENDLINE 
                        | SENTRETURN 
                        | SENTLLAMARFUNC;

GLOBALVAR           ::= CREAVARINT 
                        | CREAASIGVARINT 
                        | CREAVARFLOAT 
                        | CREAASIGVARFLOAT 
                        | CREAVARBOOL 
                        | CREAASIGVARBOOL 
                        | CREAVARCHAR 
                        | CREAASIGVARCHAR 
                        | CREAVARSTRING 
                        | CREAASIGVARSTRING;
VALORPROGRAMA       ::= CREAFUNC 
                        | GLOBALVAR 
                        | COMENTARIOS;
VALORESPROGRAMA     ::= VALORPROGRAMA VALORESPROGRAMA;
PROGRAMA            ::= FUNCMAIN
                        | FUNCMAIN VALORESPROGRAMA
                        | VALORESPROGRAMA FUNCMAIN
                        | VALORESPROGRAMA FUNCMAIN
                        VALORESPROGRAMA;

INICIO              ::= PROGRAMA {: /*imprimirTablaSimbolos();*/ imprimirCodigo3D(); imprimirCodigoMIPS();:};